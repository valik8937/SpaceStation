
--- START: ./src/SpaceStation.Core/obj/Debug/net9.0/SpaceStation.Core.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Core/obj/Debug/net9.0/SpaceStation.Core.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Core/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Core/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Core/obj/Debug/net9.0/SpaceStation.Core.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Core")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Core/obj/Debug/net9.0/SpaceStation.Core.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Core/Entities/EntityManager.cs ---
using Arch.Core;

namespace SpaceStation.Core.Entities;

/// <summary>
/// Wrapper around Arch.Core.World for entity management.
/// Provides a simplified API for common operations.
/// </summary>
public sealed class EntityManager : IDisposable
{
    /// <summary>
    /// The underlying Arch ECS World.
    /// </summary>
    public World World { get; }
    
    /// <summary>
    /// Event raised when an entity is created.
    /// </summary>
    public event Action<Entity>? EntityCreated;
    
    /// <summary>
    /// Event raised when an entity is destroyed.
    /// </summary>
    public event Action<Entity>? EntityDestroyed;
    
    public EntityManager()
    {
        World = World.Create();
    }
    
    /// <summary>
    /// Creates an entity with specified components.
    /// </summary>
    public Entity Create<T1>(T1 c1)
    {
        var entity = World.Create(c1);
        EntityCreated?.Invoke(entity);
        return entity;
    }
    
    /// <summary>
    /// Creates an entity with specified components.
    /// </summary>
    public Entity Create<T1, T2>(T1 c1, T2 c2)
    {
        var entity = World.Create(c1, c2);
        EntityCreated?.Invoke(entity);
        return entity;
    }
    
    /// <summary>
    /// Creates an entity with specified components.
    /// </summary>
    public Entity Create<T1, T2, T3>(T1 c1, T2 c2, T3 c3)
    {
        var entity = World.Create(c1, c2, c3);
        EntityCreated?.Invoke(entity);
        return entity;
    }
    
    /// <summary>
    /// Creates an entity with specified components.
    /// </summary>
    public Entity Create<T1, T2, T3, T4>(T1 c1, T2 c2, T3 c3, T4 c4)
    {
        var entity = World.Create(c1, c2, c3, c4);
        EntityCreated?.Invoke(entity);
        return entity;
    }
    
    /// <summary>
    /// Creates an entity with specified components.
    /// </summary>
    public Entity Create<T1, T2, T3, T4, T5>(T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
    {
        var entity = World.Create(c1, c2, c3, c4, c5);
        EntityCreated?.Invoke(entity);
        return entity;
    }
    
    /// <summary>
    /// Destroys an entity.
    /// </summary>
    public void Destroy(Entity entity)
    {
        if (World.IsAlive(entity))
        {
            EntityDestroyed?.Invoke(entity);
            World.Destroy(entity);
        }
    }
    
    /// <summary>
    /// Checks if an entity is alive.
    /// </summary>
    public bool IsAlive(Entity entity) => World.IsAlive(entity);
    
    /// <summary>
    /// Gets a component from an entity.
    /// </summary>
    public ref T Get<T>(Entity entity) => ref World.Get<T>(entity);
    
    /// <summary>
    /// Tries to get a component from an entity.
    /// </summary>
    public bool TryGet<T>(Entity entity, out T component)
    {
        if (World.Has<T>(entity))
        {
            component = World.Get<T>(entity);
            return true;
        }
        component = default!;
        return false;
    }
    
    /// <summary>
    /// Checks if entity has a component.
    /// </summary>
    public bool Has<T>(Entity entity) => World.Has<T>(entity);
    
    /// <summary>
    /// Adds a component to an entity.
    /// </summary>
    public void Add<T>(Entity entity, T component) => World.Add(entity, component);
    
    /// <summary>
    /// Removes a component from an entity.
    /// </summary>
    public void Remove<T>(Entity entity) => World.Remove<T>(entity);
    
    /// <summary>
    /// Gets the count of entities in the world.
    /// </summary>
    public int EntityCount => World.Size;
    
    public void Dispose()
    {
        World.Dispose();
    }
}

--- END: ./src/SpaceStation.Core/Entities/EntityManager.cs ---

--- START: ./src/SpaceStation.Core/Systems/ISystem.cs ---
using Arch.Core;

namespace SpaceStation.Core.Systems;

/// <summary>
/// Base interface for all systems in the Entity Component System.
/// Systems contain logic and operate on entities with specific components.
/// </summary>
public interface ISystem
{
    /// <summary>
    /// Priority for system execution order. Lower values run first.
    /// </summary>
    int Priority { get; }

    /// <summary>
    /// Whether this system is currently enabled.
    /// </summary>
    bool Enabled { get; set; }

    /// <summary>
    /// Called when the system is initialized.
    /// </summary>
    void Initialize(World world);

    /// <summary>
    /// Called every game tick.
    /// </summary>
    /// <param name="deltaTime">Time since last tick in seconds.</param>
    /// <param name="world">The ECS world to query.</param>
    void Update(float deltaTime, World world);

    /// <summary>
    /// Called when the system is shut down.
    /// </summary>
    void Shutdown();
}

--- END: ./src/SpaceStation.Core/Systems/ISystem.cs ---

--- START: ./src/SpaceStation.Core/Systems/BaseSystem.cs ---
using Arch.Core;

namespace SpaceStation.Core.Systems;

/// <summary>
/// Base class for systems with common functionality.
/// </summary>
public abstract class BaseSystem : ISystem
{
    public virtual int Priority => 0;
    public bool Enabled { get; set; } = true;

    protected World World { get; private set; } = null!;

    public virtual void Initialize(World world)
    {
        World = world;
    }

    public abstract void Update(float deltaTime, World world);

    public virtual void Shutdown() { }
}

--- END: ./src/SpaceStation.Core/Systems/BaseSystem.cs ---

--- START: ./src/SpaceStation.Core/Systems/SystemManager.cs ---
using Arch.Core;

namespace SpaceStation.Core.Systems;

/// <summary>
/// Manages registration and execution of all game systems.
/// Similar to SS13's subsystem controller (SSsomething pattern).
/// </summary>
public sealed class SystemManager : IDisposable
{
    private readonly List<ISystem> _systems = new();
    private readonly World _world;
    private bool _initialized;

    public SystemManager(World world)
    {
        _world = world;
    }

    /// <summary>
    /// Registers a system for execution.
    /// </summary>
    public T RegisterSystem<T>() where T : ISystem, new()
    {
        var system = new T();
        _systems.Add(system);

        if (_initialized)
        {
            system.Initialize(_world);
        }

        // Keep systems sorted by priority
        _systems.Sort((a, b) => a.Priority.CompareTo(b.Priority));

        return system;
    }

    /// <summary>
    /// Registers an existing system instance.
    /// </summary>
    public void RegisterSystem(ISystem system)
    {
        _systems.Add(system);

        if (_initialized)
        {
            system.Initialize(_world);
        }

        _systems.Sort((a, b) => a.Priority.CompareTo(b.Priority));
    }

    /// <summary>
    /// Gets a registered system of the specified type.
    /// </summary>
    public T? GetSystem<T>() where T : class, ISystem
    {
        return _systems.OfType<T>().FirstOrDefault();
    }

    /// <summary>
    /// Initializes all registered systems.
    /// </summary>
    public void Initialize()
    {
        foreach (var system in _systems)
        {
            system.Initialize(_world);
        }
        _initialized = true;
    }

    /// <summary>
    /// Updates all enabled systems.
    /// </summary>
    public void Update(float deltaTime)
    {
        foreach (var system in _systems)
        {
            if (system.Enabled)
            {
                system.Update(deltaTime, _world);
            }
        }
    }

    /// <summary>
    /// Shuts down all systems.
    /// </summary>
    public void Shutdown()
    {
        foreach (var system in _systems)
        {
            system.Shutdown();
        }
    }

    public void Dispose()
    {
        Shutdown();
        _systems.Clear();
    }
}

--- END: ./src/SpaceStation.Core/Systems/SystemManager.cs ---

--- START: ./src/SpaceStation.Core/Events/IEvent.cs ---
namespace SpaceStation.Core.Events;

/// <summary>
/// Base interface for all game events.
/// </summary>
public interface IEvent
{
    /// <summary>
    /// Whether this event has been handled and should stop propagating.
    /// </summary>
    bool Handled { get; set; }
}

--- END: ./src/SpaceStation.Core/Events/IEvent.cs ---

--- START: ./src/SpaceStation.Core/Events/GameEvents.cs ---
using Arch.Core;

namespace SpaceStation.Core.Events;

/// <summary>
/// Base class for events that involve an entity.
/// </summary>
public abstract class EntityEventArgs : IEvent
{
    public Entity Entity { get; }
    public bool Handled { get; set; }

    protected EntityEventArgs(Entity entity)
    {
        Entity = entity;
    }
}

/// <summary>
/// Event raised when an entity takes damage.
/// </summary>
public sealed class DamageEvent : EntityEventArgs
{
    public float Amount { get; set; }
    public string DamageType { get; init; }
    public Entity? Source { get; init; }

    public DamageEvent(Entity entity, float amount, string damageType, Entity? source = null)
        : base(entity)
    {
        Amount = amount;
        DamageType = damageType;
        Source = source;
    }
}

/// <summary>
/// Event raised when an entity moves.
/// </summary>
public sealed class MoveEvent : EntityEventArgs
{
    public System.Numerics.Vector2 OldPosition { get; }
    public System.Numerics.Vector2 NewPosition { get; }

    public MoveEvent(Entity entity, System.Numerics.Vector2 oldPos, System.Numerics.Vector2 newPos)
        : base(entity)
    {
        OldPosition = oldPos;
        NewPosition = newPos;
    }
}

/// <summary>
/// Event raised when an entity interacts with another.
/// </summary>
public sealed class InteractEvent : EntityEventArgs
{
    public Entity Target { get; }
    public string InteractionType { get; }

    public InteractEvent(Entity source, Entity target, string interactionType)
        : base(source)
    {
        Target = target;
        InteractionType = interactionType;
    }
}

--- END: ./src/SpaceStation.Core/Events/GameEvents.cs ---

--- START: ./src/SpaceStation.Core/Events/EventBus.cs ---
namespace SpaceStation.Core.Events;

/// <summary>
/// Central event bus for publishing and subscribing to game events.
/// Replaces DM's RegisterSignal/SendSignal (COMSIG) system.
/// </summary>
public sealed class EventBus
{
    private readonly Dictionary<Type, List<Delegate>> _handlers = new();
    
    /// <summary>
    /// Subscribe to events of a specific type.
    /// </summary>
    public void Subscribe<T>(Action<T> handler) where T : IEvent
    {
        var type = typeof(T);
        if (!_handlers.ContainsKey(type))
        {
            _handlers[type] = new List<Delegate>();
        }
        _handlers[type].Add(handler);
    }
    
    /// <summary>
    /// Unsubscribe from events of a specific type.
    /// </summary>
    public void Unsubscribe<T>(Action<T> handler) where T : IEvent
    {
        var type = typeof(T);
        if (_handlers.TryGetValue(type, out var handlers))
        {
            handlers.Remove(handler);
        }
    }
    
    /// <summary>
    /// Raise an event to all subscribers.
    /// </summary>
    public void Raise<T>(T eventData) where T : IEvent
    {
        var type = typeof(T);
        if (!_handlers.TryGetValue(type, out var handlers))
            return;
            
        foreach (var handler in handlers)
        {
            if (eventData.Handled)
                break;
                
            ((Action<T>)handler)(eventData);
        }
    }
    
    /// <summary>
    /// Raise an event and return whether it was handled.
    /// </summary>
    public bool RaiseAndCheck<T>(T eventData) where T : IEvent
    {
        Raise(eventData);
        return eventData.Handled;
    }
    
    /// <summary>
    /// Clears all event subscriptions.
    /// </summary>
    public void Clear()
    {
        _handlers.Clear();
    }
}

--- END: ./src/SpaceStation.Core/Events/EventBus.cs ---

--- START: ./src/SpaceStation.Core/Utilities/DirectionHelper.cs ---
using System.Numerics;

namespace SpaceStation.Core.Utilities;

/// <summary>
/// Helper methods for direction calculations.
/// </summary>
public static class DirectionHelper
{
    /// <summary>
    /// All cardinal and diagonal directions.
    /// </summary>
    public static readonly Vector2[] AllDirections =
    {
        new(0, 1),   // North
        new(1, 1),   // NorthEast
        new(1, 0),   // East
        new(1, -1),  // SouthEast
        new(0, -1),  // South
        new(-1, -1), // SouthWest
        new(-1, 0),  // West
        new(-1, 1)   // NorthWest
    };
    
    /// <summary>
    /// Cardinal directions only.
    /// </summary>
    public static readonly Vector2[] CardinalDirections =
    {
        new(0, 1),  // North
        new(1, 0),  // East
        new(0, -1), // South
        new(-1, 0)  // West
    };
    
    /// <summary>
    /// Gets the opposite direction.
    /// </summary>
    public static Vector2 GetOpposite(Vector2 direction)
    {
        return -direction;
    }
    
    /// <summary>
    /// Rotates a direction 90 degrees clockwise.
    /// </summary>
    public static Vector2 RotateClockwise(Vector2 direction)
    {
        return new Vector2(direction.Y, -direction.X);
    }
    
    /// <summary>
    /// Rotates a direction 90 degrees counter-clockwise.
    /// </summary>
    public static Vector2 RotateCounterClockwise(Vector2 direction)
    {
        return new Vector2(-direction.Y, direction.X);
    }
    
    /// <summary>
    /// Gets the direction from one point to another.
    /// </summary>
    public static Vector2 GetDirection(Vector2 from, Vector2 to)
    {
        var diff = to - from;
        if (diff == Vector2.Zero)
            return Vector2.Zero;
            
        return Vector2.Normalize(diff);
    }
    
    /// <summary>
    /// Snaps a direction to the nearest cardinal or diagonal direction.
    /// </summary>
    public static Vector2 SnapToDirection(Vector2 direction)
    {
        if (direction == Vector2.Zero)
            return Vector2.Zero;
            
        var normalized = Vector2.Normalize(direction);
        Vector2 best = AllDirections[0];
        float bestDot = Vector2.Dot(normalized, best);
        
        for (int i = 1; i < AllDirections.Length; i++)
        {
            var dot = Vector2.Dot(normalized, AllDirections[i]);
            if (dot > bestDot)
            {
                bestDot = dot;
                best = AllDirections[i];
            }
        }
        
        return best;
    }
}

--- END: ./src/SpaceStation.Core/Utilities/DirectionHelper.cs ---

--- START: ./src/SpaceStation.Core/Utilities/RandomHelper.cs ---
namespace SpaceStation.Core.Utilities;

/// <summary>
/// Thread-safe random number generator with game-specific utilities.
/// </summary>
public static class RandomHelper
{
    private static readonly ThreadLocal<Random> _random = new(() => new Random());
    
    /// <summary>
    /// Gets a random integer between min (inclusive) and max (exclusive).
    /// </summary>
    public static int Next(int min, int max) => _random.Value!.Next(min, max);
    
    /// <summary>
    /// Gets a random integer between 0 and max (exclusive).
    /// </summary>
    public static int Next(int max) => _random.Value!.Next(max);
    
    /// <summary>
    /// Gets a random float between 0 and 1.
    /// </summary>
    public static float NextFloat() => (float)_random.Value!.NextDouble();
    
    /// <summary>
    /// Gets a random float between min and max.
    /// </summary>
    public static float NextFloat(float min, float max) => min + (max - min) * NextFloat();
    
    /// <summary>
    /// Returns true with the given probability (0-1).
    /// </summary>
    public static bool Prob(float probability) => NextFloat() < probability;
    
    /// <summary>
    /// Returns true with the given percentage (0-100).
    /// Similar to DM's prob() function.
    /// </summary>
    public static bool Prob(int percentage) => Next(100) < percentage;
    
    /// <summary>
    /// Picks a random element from a list.
    /// Similar to DM's pick().
    /// </summary>
    public static T Pick<T>(IList<T> list) => list[Next(list.Count)];
    
    /// <summary>
    /// Picks a random element from params.
    /// Similar to DM's pick().
    /// </summary>
    public static T Pick<T>(params T[] items) => items[Next(items.Length)];
    
    /// <summary>
    /// Shuffles a list in place.
    /// </summary>
    public static void Shuffle<T>(IList<T> list)
    {
        var random = _random.Value!;
        for (int i = list.Count - 1; i > 0; i--)
        {
            int j = random.Next(i + 1);
            (list[i], list[j]) = (list[j], list[i]);
        }
    }
}

--- END: ./src/SpaceStation.Core/Utilities/RandomHelper.cs ---

--- START: ./src/SpaceStation.Core/Utilities/MathHelper.cs ---
namespace SpaceStation.Core.Utilities;

/// <summary>
/// Math helper utilities.
/// </summary>
public static class MathHelper
{
    /// <summary>
    /// Clamps a value between min and max.
    /// </summary>
    public static float Clamp(float value, float min, float max)
    {
        return Math.Max(min, Math.Min(max, value));
    }
    
    /// <summary>
    /// Clamps a value between min and max.
    /// </summary>
    public static int Clamp(int value, int min, int max)
    {
        return Math.Max(min, Math.Min(max, value));
    }
    
    /// <summary>
    /// Linear interpolation between two values.
    /// </summary>
    public static float Lerp(float a, float b, float t)
    {
        return a + (b - a) * Clamp(t, 0f, 1f);
    }
    
    /// <summary>
    /// Returns the Manhattan distance between two points.
    /// </summary>
    public static float ManhattanDistance(float x1, float y1, float x2, float y2)
    {
        return Math.Abs(x2 - x1) + Math.Abs(y2 - y1);
    }
    
    /// <summary>
    /// Returns the Chebyshev distance (chess king distance) between two points.
    /// </summary>
    public static float ChebyshevDistance(float x1, float y1, float x2, float y2)
    {
        return Math.Max(Math.Abs(x2 - x1), Math.Abs(y2 - y1));
    }
    
    /// <summary>
    /// Converts degrees to radians.
    /// </summary>
    public static float ToRadians(float degrees) => degrees * MathF.PI / 180f;
    
    /// <summary>
    /// Converts radians to degrees.
    /// </summary>
    public static float ToDegrees(float radians) => radians * 180f / MathF.PI;
}

--- END: ./src/SpaceStation.Core/Utilities/MathHelper.cs ---

--- START: ./src/SpaceStation.Shared/obj/Debug/net9.0/SpaceStation.Shared.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Shared/obj/Debug/net9.0/SpaceStation.Shared.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Shared/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Shared/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Shared/obj/Debug/net9.0/SpaceStation.Shared.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Shared/obj/Debug/net9.0/SpaceStation.Shared.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Shared/Enums/Direction.cs ---
namespace SpaceStation.Shared.Enums;

/// <summary>
/// Cardinal and diagonal directions.
/// Matches SS13's direction flags.
/// </summary>
[Flags]
public enum Direction : byte
{
    None = 0,
    North = 1,
    South = 2,
    East = 4,
    West = 8,
    NorthEast = North | East,
    NorthWest = North | West,
    SouthEast = South | East,
    SouthWest = South | West
}

--- END: ./src/SpaceStation.Shared/Enums/Direction.cs ---

--- START: ./src/SpaceStation.Shared/Enums/DamageType.cs ---
namespace SpaceStation.Shared.Enums;

/// <summary>
/// Types of damage that can be inflicted.
/// </summary>
public enum DamageType
{
    Brute,
    Burn,
    Toxin,
    Oxygen,
    Clone,
    Stamina,
    Brain,
    Cellular
}

/// <summary>
/// Damage groups for resistance/weakness calculations.
/// </summary>
public enum DamageGroup
{
    Physical,  // Brute + Burn
    Chemical,  // Toxin + Clone
    Biological // Oxygen + Clone + Cellular
}

--- END: ./src/SpaceStation.Shared/Enums/DamageType.cs ---

--- START: ./src/SpaceStation.Shared/Enums/MobState.cs ---
namespace SpaceStation.Shared.Enums;

/// <summary>
/// States a living mob can be in.
/// </summary>
public enum MobState
{
    /// <summary>Normal functioning state.</summary>
    Alive,
    
    /// <summary>Critically injured, near death.</summary>
    Critical,
    
    /// <summary>Dead but potentially revivable.</summary>
    Dead,
    
    /// <summary>Unconscious but stable.</summary>
    Unconscious,
    
    /// <summary>Unable to be revived.</summary>
    Gibbed
}

/// <summary>
/// Types of consciousness for mobs.
/// </summary>
public enum Consciousness
{
    /// <summary>Fully conscious and aware.</summary>
    Conscious,
    
    /// <summary>Sleeping or knocked out.</summary>
    Unconscious,
    
    /// <summary>In a coma.</summary>
    Comatose
}

--- END: ./src/SpaceStation.Shared/Enums/MobState.cs ---

--- START: ./src/SpaceStation.Shared/Enums/TurfType.cs ---
namespace SpaceStation.Shared.Enums;

/// <summary>
/// Types of tiles in the game world.
/// </summary>
public enum TurfType
{
    // Space
    Space,
    
    // Floors
    FloorPlating,
    FloorSteel,
    FloorWhite,
    FloorDark,
    FloorWood,
    FloorCarpet,
    FloorGrass,
    FloorSand,
    FloorLava,
    FloorWater,
    
    // Walls
    WallSteel,
    WallReinforced,
    WallPlasteel,
    WallShuttle,
    
    // Special
    Lattice,
    Catwalk
}

/// <summary>
/// Flags for turf properties.
/// </summary>
[Flags]
public enum TurfFlags
{
    None = 0,
    Airtight = 1,
    Transparent = 2,
    Dense = 4,
    Slippery = 8,
    Burnable = 16,
    Buildable = 32
}

--- END: ./src/SpaceStation.Shared/Enums/TurfType.cs ---

--- START: ./src/SpaceStation.Shared/Enums/AtmosGas.cs ---
namespace SpaceStation.Shared.Enums;

/// <summary>
/// Types of atmospheric gases.
/// </summary>
public enum AtmosGas
{
    Oxygen,
    Nitrogen,
    CarbonDioxide,
    Plasma,
    NitrousOxide,
    BZ,
    Tritium,
    WaterVapor,
    Miasma,
    Nitryl,
    Pluoxium,
    Hydrogen,
    HyperNoblium,
    Stimulum,
    Freon,
    Healium,
    ProtoNitrate,
    Zauker,
    Halon,
    Helium,
    AntiNoblium
}

/// <summary>
/// Pressure danger levels.
/// </summary>
public enum PressureLevel
{
    None,
    Low,
    Normal,
    High,
    Hazardous,
    Lethal
}

--- END: ./src/SpaceStation.Shared/Enums/AtmosGas.cs ---

--- START: ./src/SpaceStation.Shared/Constants/GameConstants.cs ---
namespace SpaceStation.Shared.Constants;

/// <summary>
/// Core game constants.
/// </summary>
public static class GameConstants
{
    // World settings
    public const int TileSize = 32;
    public const int DefaultMapWidth = 255;
    public const int DefaultMapHeight = 255;
    public const float TickRate = 20f; // ticks per second
    public const float TickDuration = 1f / TickRate;
    
    // Movement
    public const float DefaultMoveSpeed = 1.0f;
    public const float RunMultiplier = 1.5f;
    public const float CrawlMultiplier = 0.3f;
    
    // Combat
    public const float DefaultMeleeDamage = 5f;
    public const float DefaultMeleeRange = 1.5f;
    public const float DefaultProjectileSpeed = 25f;
    
    // Interaction
    public const float DefaultInteractRange = 1.5f;
    public const float DefaultViewRange = 7f;
    
    // Health
    public const float DefaultMaxHealth = 100f;
    public const float CriticalHealthThreshold = 0f;
    public const float DeathThreshold = -100f;
}

--- END: ./src/SpaceStation.Shared/Constants/GameConstants.cs ---

--- START: ./src/SpaceStation.Shared/Constants/AtmosConstants.cs ---
namespace SpaceStation.Shared.Constants;

/// <summary>
/// Atmospheric simulation constants.
/// </summary>
public static class AtmosConstants
{
    // Gas constants
    public const float OneAtmosphere = 101.325f; // kPa
    public const float StandardTemp = 293.15f;   // 20°C in Kelvin
    public const float T0C = 273.15f;            // 0°C in Kelvin
    public const float T20C = 293.15f;           // 20°C in Kelvin
    
    // Pressure limits
    public const float HazardLowPressure = 20f;
    public const float WarningLowPressure = 50f;
    public const float WarningHighPressure = 550f;
    public const float HazardHighPressure = 750f;
    
    // Temperature limits
    public const float MinTemp = 2.7f;           // Cosmic background
    public const float MaxTemp = 100000f;
    public const float ColdDamageThreshold = 260f;
    public const float HeatDamageThreshold = 360f;
    
    // Oxygen levels (percentage)
    public const float MinBreathableOxygen = 16f;
    public const float OptimalOxygen = 21f;
    public const float ToxicOxygenThreshold = 140f;
    
    // Simulation
    public const float AtmosTickRate = 0.5f;     // seconds
    public const int GroupSize = 8;              // tiles per gas group
    public const float MinTransferMoles = 0.01f;
}

--- END: ./src/SpaceStation.Shared/Constants/AtmosConstants.cs ---

--- START: ./src/SpaceStation.Shared/Prototypes/IPrototype.cs ---
namespace SpaceStation.Shared.Prototypes;

/// <summary>
/// Interface for prototype definitions.
/// Prototypes define templates for creating entities via data (YAML/JSON).
/// </summary>
public interface IPrototype
{
    /// <summary>
    /// Unique identifier for this prototype.
    /// </summary>
    string ID { get; }
}

/// <summary>
/// Attribute to mark a class as a prototype type.
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public sealed class PrototypeAttribute : Attribute
{
    public string TypeName { get; }

    public PrototypeAttribute(string typeName)
    {
        TypeName = typeName;
    }
}

--- END: ./src/SpaceStation.Shared/Prototypes/IPrototype.cs ---

--- START: ./src/SpaceStation.Shared/Prototypes/EntityPrototype.cs ---
namespace SpaceStation.Shared.Prototypes;

/// <summary>
/// Prototype for entity definitions.
/// These are loaded from YAML/JSON files.
/// </summary>
[Prototype("entity")]
public sealed class EntityPrototype : IPrototype
{
    public string ID { get; set; } = string.Empty;

    /// <summary>
    /// Display name of the entity.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Description shown when examining.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Parent prototype to inherit from.
    /// </summary>
    public string? Parent { get; set; }

    /// <summary>
    /// Path to the sprite/icon.
    /// </summary>
    public string? Sprite { get; set; }

    /// <summary>
    /// Components to add to this entity.
    /// </summary>
    public List<ComponentData> Components { get; set; } = new();
}

/// <summary>
/// Component data from prototype definition.
/// </summary>
public sealed class ComponentData
{
    /// <summary>
    /// Type name of the component.
    /// </summary>
    public string Type { get; set; } = string.Empty;

    /// <summary>
    /// Component-specific data.
    /// </summary>
    public Dictionary<string, object> Data { get; set; } = new();
}

--- END: ./src/SpaceStation.Shared/Prototypes/EntityPrototype.cs ---

--- START: ./src/SpaceStation.Shared/Prototypes/PrototypeManager.cs ---
using System.Text.Json;

namespace SpaceStation.Shared.Prototypes;

/// <summary>
/// Manages loading and retrieval of prototypes.
/// </summary>
public sealed class PrototypeManager
{
    private readonly Dictionary<Type, Dictionary<string, IPrototype>> _prototypes = new();
    
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true
    };

    /// <summary>
    /// Registers a prototype.
    /// </summary>
    public void Register<T>(T prototype) where T : IPrototype
    {
        var type = typeof(T);
        if (!_prototypes.ContainsKey(type))
        {
            _prototypes[type] = new Dictionary<string, IPrototype>(StringComparer.OrdinalIgnoreCase);
        }
        _prototypes[type][prototype.ID] = prototype;
    }

    /// <summary>
    /// Gets a prototype by ID.
    /// </summary>
    public T Get<T>(string id) where T : IPrototype
    {
        return (T)_prototypes[typeof(T)][id];
    }

    /// <summary>
    /// Tries to get a prototype by ID.
    /// </summary>
    public bool TryGet<T>(string id, out T? prototype) where T : class, IPrototype
    {
        if (_prototypes.TryGetValue(typeof(T), out var dict) &&
            dict.TryGetValue(id, out var proto))
        {
            prototype = (T)proto;
            return true;
        }
        prototype = null;
        return false;
    }

    /// <summary>
    /// Gets all prototypes of a type.
    /// </summary>
    public IEnumerable<T> GetAll<T>() where T : IPrototype
    {
        if (_prototypes.TryGetValue(typeof(T), out var dict))
        {
            return dict.Values.Cast<T>();
        }
        return Enumerable.Empty<T>();
    }

    /// <summary>
    /// Checks if a prototype exists.
    /// </summary>
    public bool Has<T>(string id) where T : IPrototype
    {
        return _prototypes.TryGetValue(typeof(T), out var dict) && dict.ContainsKey(id);
    }
    
    /// <summary>
    /// Total prototype count.
    /// </summary>
    public int PrototypeCount => _prototypes.Values.Sum(d => d.Count);

    /// <summary>
    /// Loads prototypes from a JSON file.
    /// </summary>
    public void LoadFromJson<T>(string json) where T : IPrototype
    {
        var prototypes = JsonSerializer.Deserialize<List<T>>(json, JsonOptions);
        if (prototypes == null) return;

        foreach (var prototype in prototypes)
        {
            Register(prototype);
        }
    }
    
    /// <summary>
    /// Loads all JSON prototype files from a directory recursively.
    /// </summary>
    public void LoadDirectory(string path)
    {
        if (!Directory.Exists(path))
        {
            Console.WriteLine($"[PrototypeManager] Directory not found: {path}");
            return;
        }
        
        var jsonFiles = Directory.GetFiles(path, "*.json", SearchOption.AllDirectories);
        var loaded = 0;
        var errors = 0;
        
        foreach (var file in jsonFiles)
        {
            try
            {
                var json = File.ReadAllText(file);
                LoadFromJson<EntityPrototype>(json);
                loaded++;
            }
            catch (Exception ex)
            {
                errors++;
                Console.WriteLine($"[PrototypeManager] Error loading {file}: {ex.Message}");
            }
        }
        
        // Resolve parent inheritance
        ResolveInheritance();
        
        Console.WriteLine($"[PrototypeManager] Loaded {loaded} files, {PrototypeCount} prototypes, {errors} errors");
    }
    
    /// <summary>
    /// Resolves prototype inheritance (Parent field).
    /// </summary>
    private void ResolveInheritance()
    {
        if (!_prototypes.TryGetValue(typeof(EntityPrototype), out var entityDict))
            return;
            
        foreach (var proto in entityDict.Values.Cast<EntityPrototype>())
        {
            if (string.IsNullOrEmpty(proto.Parent))
                continue;
                
            if (!entityDict.TryGetValue(proto.Parent, out var parentProto))
            {
                Console.WriteLine($"[PrototypeManager] Warning: Prototype '{proto.ID}' has unknown parent '{proto.Parent}'");
                continue;
            }
            
            var parent = (EntityPrototype)parentProto;
            
            // Inherit name if not set
            if (string.IsNullOrEmpty(proto.Name))
                proto.Name = parent.Name;
                
            // Inherit description if not set
            if (string.IsNullOrEmpty(proto.Description))
                proto.Description = parent.Description;
                
            // Inherit sprite if not set
            if (string.IsNullOrEmpty(proto.Sprite))
                proto.Sprite = parent.Sprite;
                
            // Merge components (child overrides parent)
            var parentComponents = new Dictionary<string, ComponentData>(StringComparer.OrdinalIgnoreCase);
            foreach (var comp in parent.Components)
            {
                parentComponents[comp.Type] = comp;
            }
            
            foreach (var comp in proto.Components)
            {
                parentComponents[comp.Type] = comp;
            }
            
            proto.Components = parentComponents.Values.ToList();
        }
    }
}


--- END: ./src/SpaceStation.Shared/Prototypes/PrototypeManager.cs ---

--- START: ./src/SpaceStation.Shared/Network/Packets/PacketType.cs ---
namespace SpaceStation.Shared.Network;

/// <summary>
/// Types of network packets.
/// </summary>
public enum PacketType : byte
{
    // Connection (0-19)
    ConnectionRequest = 0,
    ConnectionAccepted = 1,
    ConnectionDenied = 2,
    Disconnect = 3,
    
    // Game State (20-39)
    WorldSnapshot = 20,
    EntitySpawn = 21,
    EntityDespawn = 22,
    EntityUpdate = 23,
    
    // Player Input (40-59)
    PlayerInput = 40,
    PlayerCommand = 41,
    PlayerMove = 42,
    PlayerInteract = 43,
    PlayerSpawned = 44,
    
    // Chat (60-79)
    ChatMessage = 60,
    
    // Admin (80-99)
    AdminCommand = 80
}

--- END: ./src/SpaceStation.Shared/Network/Packets/PacketType.cs ---

--- START: ./src/SpaceStation.Shared/Network/Packets/NetworkComponents.cs ---
using MemoryPack;

namespace SpaceStation.Shared.Network.Packets;

/// <summary>
/// Network-serializable transform data.
/// </summary>
[MemoryPackable]
public partial struct NetworkTransform
{
    public float X;
    public float Y;
    public float Rotation;
    public int ZLevel;
    
    public NetworkTransform(float x, float y, float rotation = 0f, int zLevel = 0)
    {
        X = x;
        Y = y;
        Rotation = rotation;
        ZLevel = zLevel;
    }
}

/// <summary>
/// Network-serializable physics data.
/// </summary>
[MemoryPackable]
public partial struct NetworkPhysics
{
    public float VelocityX;
    public float VelocityY;
    public float MoveSpeed;
    public bool Dense;
    public bool Anchored;
}

/// <summary>
/// Network-serializable sprite data.
/// </summary>
[MemoryPackable]
public partial struct NetworkSprite
{
    public string TextureId;
    public int SourceX;
    public int SourceY;
    public int SourceWidth;
    public int SourceHeight;
    public byte TintR;
    public byte TintG;
    public byte TintB;
    public byte TintA;
    public float Scale;
}

/// <summary>
/// Network-serializable health data.
/// </summary>
[MemoryPackable]
public partial struct NetworkHealth
{
    public float MaxHealth;
    public float CurrentHealth;
    public byte State; // MobState as byte
}

/// <summary>
/// A complete entity state for network transmission.
/// </summary>
[MemoryPackable]
public partial class NetworkEntity
{
    /// <summary>Server-side entity ID for tracking.</summary>
    public int EntityId { get; set; }
    
    /// <summary>Prototype ID for spawning.</summary>
    public string? PrototypeId { get; set; }
    
    /// <summary>Transform component (always present).</summary>
    public NetworkTransform Transform { get; set; }
    
    /// <summary>Optional physics data.</summary>
    public NetworkPhysics? Physics { get; set; }
    
    /// <summary>Optional sprite data.</summary>
    public NetworkSprite? Sprite { get; set; }
    
    /// <summary>Optional health data.</summary>
    public NetworkHealth? Health { get; set; }
}

--- END: ./src/SpaceStation.Shared/Network/Packets/NetworkComponents.cs ---

--- START: ./src/SpaceStation.Shared/Network/Packets/GamePackets.cs ---
using MemoryPack;

namespace SpaceStation.Shared.Network.Packets;

/// <summary>
/// Packet header containing type and metadata.
/// </summary>
[MemoryPackable]
public partial struct PacketHeader
{
    public PacketType Type;
    public uint Tick;
    public long Timestamp;
}

/// <summary>
/// World snapshot containing all entity states.
/// Sent from server to clients every tick.
/// </summary>
[MemoryPackable]
public partial class WorldSnapshotPacket
{
    public PacketHeader Header { get; set; }
    public NetworkEntity[] Entities { get; set; } = Array.Empty<NetworkEntity>();
    public int PlayerCount { get; set; }
    
    public WorldSnapshotPacket()
    {
        Header = new PacketHeader
        {
            Type = PacketType.WorldSnapshot,
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
    }
}

/// <summary>
/// Single entity spawn packet.
/// </summary>
[MemoryPackable]
public partial class EntitySpawnPacket
{
    public PacketHeader Header { get; set; }
    public NetworkEntity Entity { get; set; } = null!;
    
    public EntitySpawnPacket()
    {
        Header = new PacketHeader { Type = PacketType.EntitySpawn };
    }
}

/// <summary>
/// Entity despawn packet.
/// </summary>
[MemoryPackable]
public partial class EntityDespawnPacket
{
    public PacketHeader Header { get; set; }
    public int EntityId { get; set; }
    
    public EntityDespawnPacket()
    {
        Header = new PacketHeader { Type = PacketType.EntityDespawn };
    }
}

/// <summary>
/// Connection accepted response.
/// </summary>
[MemoryPackable]
public partial class ConnectionAcceptedPacket
{
    public PacketHeader Header { get; set; }
    public int ClientId { get; set; }
    public string ServerName { get; set; } = "Space Station 13";
    public int TickRate { get; set; } = NetworkConstants.TickRate;
    
    public ConnectionAcceptedPacket()
    {
        Header = new PacketHeader { Type = PacketType.ConnectionAccepted };
    }
}

/// <summary>
/// Connection denied response.
/// </summary>
[MemoryPackable]
public partial class ConnectionDeniedPacket
{
    public PacketHeader Header { get; set; }
    public string Reason { get; set; } = "Connection denied";
    
    public ConnectionDeniedPacket()
    {
        Header = new PacketHeader { Type = PacketType.ConnectionDenied };
    }
}

/// <summary>
/// Player input from client to server.
/// Contains movement direction from WASD.
/// </summary>
[MemoryPackable]
public partial class PlayerInputPacket
{
    public PacketHeader Header { get; set; }
    
    /// <summary>Movement direction: X (-1 left, 1 right), Y (-1 up, 1 down)</summary>
    public float MoveX { get; set; }
    public float MoveY { get; set; }
    
    /// <summary>Tick when input was generated (for lag compensation)</summary>
    public uint InputTick { get; set; }
    
    public PlayerInputPacket()
    {
        Header = new PacketHeader { Type = PacketType.PlayerInput };
    }
}

/// <summary>
/// Sent to client when their player entity is spawned.
/// Tells client which entity to follow with camera.
/// </summary>
[MemoryPackable]
public partial class PlayerSpawnedPacket
{
    public PacketHeader Header { get; set; }
    
    /// <summary>Network entity ID of the player's mob.</summary>
    public int EntityId { get; set; }
    
    public PlayerSpawnedPacket()
    {
        Header = new PacketHeader { Type = PacketType.PlayerSpawned };
    }
}

--- END: ./src/SpaceStation.Shared/Network/Packets/GamePackets.cs ---

--- START: ./src/SpaceStation.Shared/Network/NetworkConstants.cs ---
namespace SpaceStation.Shared.Network;

/// <summary>
/// Network configuration constants.
/// </summary>
public static class NetworkConstants
{
    /// <summary>Default server port.</summary>
    public const int DefaultPort = 7777;
    
    /// <summary>Connection key for authentication.</summary>
    public const string ConnectionKey = "SS13_REMAKE_v1";
    
    /// <summary>Maximum number of connected clients.</summary>
    public const int MaxPlayers = 100;
    
    /// <summary>Server tick rate (updates per second).</summary>
    public const int TickRate = 20;
    
    /// <summary>Tick duration in seconds.</summary>
    public const float TickDuration = 1f / TickRate;
    
    /// <summary>Connection timeout in milliseconds.</summary>
    public const int ConnectionTimeout = 5000;
    
    /// <summary>Disconnect timeout in milliseconds.</summary>
    public const int DisconnectTimeout = 5000;
    
    /// <summary>Ping interval in milliseconds.</summary>
    public const int PingInterval = 1000;
}

--- END: ./src/SpaceStation.Shared/Network/NetworkConstants.cs ---

--- START: ./src/SpaceStation.Shared/Network/PacketSerializer.cs ---
using LiteNetLib;
using MemoryPack;
using SpaceStation.Shared.Network.Packets;

namespace SpaceStation.Shared.Network;

/// <summary>
/// Helper class for serializing and deserializing network packets.
/// </summary>
public static class PacketSerializer
{
    /// <summary>
    /// Serializes a packet to bytes.
    /// </summary>
    public static byte[] Serialize<T>(T packet) where T : class
    {
        return MemoryPackSerializer.Serialize(packet);
    }
    
    /// <summary>
    /// Generic deserialize method for any MemoryPackable packet.
    /// </summary>
    public static T? Deserialize<T>(byte[] data) where T : class
    {
        try
        {
            return MemoryPackSerializer.Deserialize<T>(data);
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// Deserializes a world snapshot packet from bytes.
    /// </summary>
    public static WorldSnapshotPacket? DeserializeSnapshot(byte[] data)
    {
        try
        {
            return MemoryPackSerializer.Deserialize<WorldSnapshotPacket>(data);
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// Deserializes a connection accepted packet from bytes.
    /// </summary>
    public static ConnectionAcceptedPacket? DeserializeConnectionAccepted(byte[] data)
    {
        try
        {
            return MemoryPackSerializer.Deserialize<ConnectionAcceptedPacket>(data);
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// Deserializes a connection denied packet from bytes.
    /// </summary>
    public static ConnectionDeniedPacket? DeserializeConnectionDenied(byte[] data)
    {
        try
        {
            return MemoryPackSerializer.Deserialize<ConnectionDeniedPacket>(data);
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// Gets the packet type from raw data (first byte after header).
    /// </summary>
    public static PacketType GetPacketType(byte[] data)
    {
        if (data.Length < 1)
            return (PacketType)255; // Invalid
            
        return (PacketType)data[0];
    }
}

--- END: ./src/SpaceStation.Shared/Network/PacketSerializer.cs ---

--- START: ./src/SpaceStation.Shared/Map/GridConstants.cs ---
namespace SpaceStation.Shared.Map;

/// <summary>
/// Grid and tile size constants.
/// </summary>
public static class GridConstants
{
    /// <summary>Size of a single tile in pixels.</summary>
    public const int TileSize = 32;

    /// <summary>Default map width in tiles.</summary>
    public const int DefaultMapWidth = 255;

    /// <summary>Default map height in tiles.</summary>
    public const int DefaultMapHeight = 255;

    /// <summary>Maximum Z-levels supported.</summary>
    public const int MaxZLevels = 10;

    /// <summary>
    /// Converts tile coordinates to pixel coordinates (center of tile).
    /// </summary>
    public static (float X, float Y) TileToPixel(int tileX, int tileY)
    {
        return (tileX * TileSize + TileSize / 2f, tileY * TileSize + TileSize / 2f);
    }

    /// <summary>
    /// Converts pixel coordinates to tile coordinates.
    /// </summary>
    public static (int X, int Y) PixelToTile(float pixelX, float pixelY)
    {
        return ((int)(pixelX / TileSize), (int)(pixelY / TileSize));
    }

    /// <summary>
    /// Gets the flat array index for tile coordinates.
    /// </summary>
    public static int GetIndex(int x, int y, int width)
    {
        return y * width + x;
    }

    /// <summary>
    /// Gets tile coordinates from flat array index.
    /// </summary>
    public static (int X, int Y) GetCoords(int index, int width)
    {
        return (index % width, index / width);
    }
}

--- END: ./src/SpaceStation.Shared/Map/GridConstants.cs ---

--- START: ./src/SpaceStation.Shared/Map/TileData.cs ---
using MemoryPack;

namespace SpaceStation.Shared.Map;

/// <summary>
/// Tile data stored in the flat grid array.
/// Optimized for cache-friendly access.
/// </summary>
[MemoryPackable]
public partial struct TileData
{
    /// <summary>
    /// Prototype ID for the turf type.
    /// 0 = space, other values index into prototype table.
    /// </summary>
    public ushort TurfPrototypeId;

    /// <summary>
    /// Tile state flags.
    /// </summary>
    public TileFlags Flags;

    /// <summary>
    /// Current temperature in Kelvin (compressed).
    /// Actual = Temperature * 2 (0-510K range with 0.5K precision).
    /// </summary>
    public byte Temperature;

    /// <summary>
    /// Icon state variant (for smoothing junction or tile overlay).
    /// </summary>
    public byte Variant;

    public TileData(ushort prototypeId = 0)
    {
        TurfPrototypeId = prototypeId;
        Flags = TileFlags.None;
        Temperature = 147; // ~293K (room temperature)
        Variant = 0;
    }

    /// <summary>Gets/sets the actual temperature in Kelvin.</summary>
    public float ActualTemperature
    {
        get => Temperature * 2f;
        set => Temperature = (byte)Math.Clamp(value / 2f, 0, 255);
    }

    public bool Intact
    {
        get => (Flags & TileFlags.Intact) != 0;
        set => Flags = value ? Flags | TileFlags.Intact : Flags & ~TileFlags.Intact;
    }

    public bool BlocksAir
    {
        get => (Flags & TileFlags.BlocksAir) != 0;
        set => Flags = value ? Flags | TileFlags.BlocksAir : Flags & ~TileFlags.BlocksAir;
    }

    public bool Dense
    {
        get => (Flags & TileFlags.Dense) != 0;
        set => Flags = value ? Flags | TileFlags.Dense : Flags & ~TileFlags.Dense;
    }

    public bool Opaque
    {
        get => (Flags & TileFlags.Opaque) != 0;
        set => Flags = value ? Flags | TileFlags.Opaque : Flags & ~TileFlags.Opaque;
    }
}

/// <summary>
/// Bit flags for tile state.
/// </summary>
[Flags]
public enum TileFlags : byte
{
    None = 0,

    /// <summary>Floor plating is intact.</summary>
    Intact = 1 << 0,

    /// <summary>Blocks air flow.</summary>
    BlocksAir = 1 << 1,

    /// <summary>Blocks movement (dense).</summary>
    Dense = 1 << 2,

    /// <summary>Blocks vision (opaque).</summary>
    Opaque = 1 << 3,

    /// <summary>Has atmos simulation running.</summary>
    Simulated = 1 << 4,

    /// <summary>Is a space tile.</summary>
    Space = 1 << 5,

    /// <summary>Needs smoothing update.</summary>
    DirtySmoothing = 1 << 6
}

--- END: ./src/SpaceStation.Shared/Map/TileData.cs ---

--- START: ./src/SpaceStation.Shared/Map/MapManager.cs ---
using System.Text.Json;
using System.Numerics; // Keep this for Vector2 in GridConstants, though not directly used in MapManager anymore.
// using Arch.Core; // Removed as per instruction
// using SpaceStation.Content.Components; // Removed as per instruction

namespace SpaceStation.Shared.Map;

/// <summary>
/// Manages the game map grid data.
/// Uses a flat 1D array for cache-friendly access.
/// Entity spawning should be done by server/client using this data.
/// </summary>
public class MapManager
{
    private TileData[] _tiles = Array.Empty<TileData>();
    private int _width;
    private int _height;
    private int _zLevel;

    /// <summary>Map width in tiles.</summary>
    public int Width => _width;

    /// <summary>Map height in tiles.</summary>
    public int Height => _height;

    /// <summary>Z-level of this map.</summary>
    public int ZLevel => _zLevel;

    /// <summary>Total tile count.</summary>
    public int TileCount => _tiles.Length;

    /// <summary>
    /// Gets a reference to tile data at the given coordinates.
    /// </summary>
    public ref TileData GetTile(int x, int y)
    {
        if (x < 0 || x >= _width || y < 0 || y >= _height)
        {
            throw new ArgumentOutOfRangeException($"Tile coordinates ({x}, {y}) out of bounds ({_width}x{_height})");
        }

        return ref _tiles[GridConstants.GetIndex(x, y, _width)];
    }

    /// <summary>
    /// Tries to get tile data, returns false if out of bounds.
    /// </summary>
    public bool TryGetTile(int x, int y, out TileData tile)
    {
        if (x < 0 || x >= _width || y < 0 || y >= _height)
        {
            tile = default;
            return false;
        }

        tile = _tiles[GridConstants.GetIndex(x, y, _width)];
        return true;
    }

    /// <summary>
    /// Sets tile data at the given coordinates.
    /// </summary>
    public void SetTile(int x, int y, TileData data)
    {
        if (x < 0 || x >= _width || y < 0 || y >= _height)
            return;

        _tiles[GridConstants.GetIndex(x, y, _width)] = data;
    }

    /// <summary>
    /// Initializes an empty map of the given size.
    /// </summary>
    public void Initialize(int width, int height, int zLevel = 0, ushort defaultPrototype = 0)
    {
        _width = width;
        _height = height;
        _zLevel = zLevel;
        _tiles = new TileData[width * height];

        // Initialize all tiles
        var defaultTile = new TileData(defaultPrototype);
        Array.Fill(_tiles, defaultTile);

        Console.WriteLine($"[MapManager] Initialized {width}x{height} map on Z-level {zLevel}");
    }

    /// <summary>
    /// Loads a map from a simple text format.
    /// Each character represents a tile type.
    /// </summary>
    public void LoadFromText(string mapData, Dictionary<char, ushort>? legend = null)
    {
        legend ??= new Dictionary<char, ushort>
        {
            { ' ', 0 },  // Space
            { '.', 1 },  // Floor
            { '#', 2 },  // Wall
            { 'D', 3 },  // Door
        };

        var lines = mapData.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var height = lines.Length;
        var width = lines.Max(l => l.Length);

        Initialize(width, height);

        for (int y = 0; y < lines.Length; y++)
        {
            var line = lines[y];
            for (int x = 0; x < line.Length; x++)
            {
                var c = line[x];
                if (legend.TryGetValue(c, out var prototypeId))
                {
                    var tile = new TileData(prototypeId);

                    // Set common flags based on type
                    if (prototypeId == 0) // Space
                    {
                        tile.Flags |= TileFlags.Space;
                    }
                    else if (prototypeId == 1) // Floor
                    {
                        tile.Flags |= TileFlags.Intact | TileFlags.Simulated;
                    }
                    else if (prototypeId == 2) // Wall
                    {
                        tile.Flags |= TileFlags.Dense | TileFlags.Opaque | TileFlags.BlocksAir;
                    }

                    SetTile(x, y, tile);
                }
            }
        }

        Console.WriteLine($"[MapManager] Loaded text map {width}x{height}");
    }

    /// <summary>
    /// Loads a map from JSON format.
    /// </summary>
    public void LoadFromJson(string jsonPath)
    {
        var json = File.ReadAllText(jsonPath);
        var mapJson = JsonSerializer.Deserialize<MapJson>(json);

        if (mapJson == null)
        {
            throw new InvalidDataException($"Invalid map format: {jsonPath}");
        }

        Initialize(mapJson.Width, mapJson.Height, mapJson.ZLevel);

        if (mapJson.Tiles != null)
        {
            // Direct tile array
            for (int i = 0; i < Math.Min(mapJson.Tiles.Length, _tiles.Length); i++)
            {
                _tiles[i] = new TileData((ushort)mapJson.Tiles[i]);
            }
        }
        else if (mapJson.Data != null)
        {
            // Text-based data
            LoadFromText(mapJson.Data, mapJson.Legend);
        }

        Console.WriteLine($"[MapManager] Loaded JSON map from {jsonPath}");
    }


    /// <summary>
    /// Gets the raw tile array (for serialization).
    /// </summary>
    public TileData[] GetTileArray() => _tiles;

    /// <summary>
    /// Checks if a tile is passable for movement.
    /// </summary>
    public bool IsPassable(int x, int y)
    {
        if (x < 0 || x >= _width || y < 0 || y >= _height)
            return false;

        var tile = _tiles[GridConstants.GetIndex(x, y, _width)];
        return !tile.Dense;
    }

    /// <summary>
    /// Checks if a tile blocks vision.
    /// </summary>
    public bool BlocksVision(int x, int y)
    {
        if (x < 0 || x >= _width || y < 0 || y >= _height)
            return true;

        var tile = _tiles[GridConstants.GetIndex(x, y, _width)];
        return tile.Opaque;
    }
}

/// <summary>
/// JSON format for map files.
/// </summary>
internal class MapJson
{
    public int Width { get; set; }
    public int Height { get; set; }
    public int ZLevel { get; set; }
    public int[]? Tiles { get; set; }
    public string? Data { get; set; }
    public Dictionary<char, ushort>? Legend { get; set; }
}

--- END: ./src/SpaceStation.Shared/Map/MapManager.cs ---

--- START: ./src/SpaceStation.Content/obj/Debug/net9.0/SpaceStation.Content.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Content/obj/Debug/net9.0/SpaceStation.Content.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Content/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Content/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Content/obj/Debug/net9.0/SpaceStation.Content.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Content")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Content")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Content")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Content/obj/Debug/net9.0/SpaceStation.Content.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Content/Components/Physics/PhysicsComponents.cs ---
using System.Numerics;

namespace SpaceStation.Content.Components;

/// <summary>
/// Transform component for position and rotation.
/// </summary>
public record struct Transform(
    Vector2 Position = default,
    float Rotation = 0f,
    int ZLevel = 0
);

/// <summary>
/// Physics component for movement and collision.
/// </summary>
public record struct Physics(
    Vector2 Velocity = default,
    float MoveSpeed = 1.0f,
    float Mass = 1.0f,
    float Friction = 0.5f,
    bool Dense = true,
    bool Anchored = false
);

--- END: ./src/SpaceStation.Content/Components/Physics/PhysicsComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/Health/HealthComponents.cs ---
using SpaceStation.Shared.Enums;

namespace SpaceStation.Content.Components;

/// <summary>
/// Health component for entity health and state.
/// </summary>
public record struct Health(
    float MaxHealth = 100f,
    float CurrentHealth = 100f,
    MobState State = MobState.Alive
)
{
    public readonly float HealthPercent => MaxHealth > 0 ? CurrentHealth / MaxHealth : 0f;
    public readonly bool IsDead => State == MobState.Dead || State == MobState.Gibbed;
    public readonly bool IsCritical => State == MobState.Critical;
}

/// <summary>
/// Damageable component tracking damage by type.
/// </summary>
public struct Damageable
{
    public float BruteDamage;
    public float BurnDamage;
    public float ToxinDamage;
    public float OxygenDamage;
    public float StaminaDamage;

    public readonly float TotalDamage =>
        BruteDamage + BurnDamage + ToxinDamage + OxygenDamage + StaminaDamage;

    public void ApplyDamage(DamageType type, float amount)
    {
        switch (type)
        {
            case DamageType.Brute: BruteDamage = MathF.Max(0, BruteDamage + amount); break;
            case DamageType.Burn: BurnDamage = MathF.Max(0, BurnDamage + amount); break;
            case DamageType.Toxin: ToxinDamage = MathF.Max(0, ToxinDamage + amount); break;
            case DamageType.Oxygen: OxygenDamage = MathF.Max(0, OxygenDamage + amount); break;
            case DamageType.Stamina: StaminaDamage = MathF.Max(0, StaminaDamage + amount); break;
        }
    }

    public void HealDamage(DamageType type, float amount)
    {
        ApplyDamage(type, -amount);
    }
}

--- END: ./src/SpaceStation.Content/Components/Health/HealthComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/Atmos/AtmosComponents.cs ---
using SpaceStation.Shared.Enums;

namespace SpaceStation.Content.Components;

/// <summary>
/// Atmospheric gas mixture component.
/// </summary>
public struct Atmosphere
{
    // Gas amounts in moles
    public float Oxygen;
    public float Nitrogen;
    public float CarbonDioxide;
    public float Plasma;
    public float NitrousOxide;

    /// <summary>
    /// Temperature in Kelvin.
    /// </summary>
    public float Temperature;

    /// <summary>
    /// Volume in liters.
    /// </summary>
    public float Volume;

    public readonly float TotalMoles =>
        Oxygen + Nitrogen + CarbonDioxide + Plasma + NitrousOxide;

    public readonly float Pressure =>
        Volume > 0 ? (TotalMoles * 8.314f * Temperature) / Volume : 0f;

    public static Atmosphere CreateStandard(float volume = 2500f)
    {
        return new Atmosphere
        {
            Oxygen = 21f,
            Nitrogen = 79f,
            CarbonDioxide = 0f,
            Plasma = 0f,
            NitrousOxide = 0f,
            Temperature = 293.15f, // 20°C
            Volume = volume
        };
    }
}

/// <summary>
/// Gas container component for tanks and canisters.
/// </summary>
public record struct GasContainer(
    float MaxPressure = 10000f,
    bool ValveOpen = false,
    float ReleasePressure = 101.325f
);

/// <summary>
/// Marker component for entities exposed to space.
/// </summary>
public struct ExposedToSpace { }

/// <summary>
/// Marker component for sealed areas.
/// </summary>
public struct Sealed { }

--- END: ./src/SpaceStation.Content/Components/Atmos/AtmosComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/Items/ItemComponents.cs ---
using SpaceStation.Shared.Enums;

namespace SpaceStation.Content.Components;

/// <summary>
/// Item size categories.
/// </summary>
public enum ItemSize
{
    Tiny,
    Small,
    Normal,
    Large,
    Huge,
    Gigantic
}

/// <summary>
/// Clothing slot types.
/// </summary>
public enum ClothingSlot
{
    None,
    Head,
    Mask,
    Neck,
    Eyes,
    Ears,
    Uniform,
    Suit,
    Gloves,
    Shoes,
    Back,
    Belt,
    Pocket,
    Id
}

/// <summary>
/// Tool quality types.
/// </summary>
public enum ToolQuality
{
    Cutting,
    Screwing,
    Prying,
    Pulsing,
    Welding,
    Anchoring,
    Digging,
    Mining,
    Sawing
}

/// <summary>
/// Item component for pickable objects.
/// </summary>
public record struct Item(
    string Name = "item",
    float Weight = 1f,
    ItemSize Size = ItemSize.Small,
    bool InInventory = false
);

/// <summary>
/// Tool component with qualities.
/// </summary>
public struct Tool
{
    public ToolQuality Qualities; // Using flags would be better
    public float SpeedModifier;

    public Tool()
    {
        Qualities = 0;
        SpeedModifier = 1f;
    }
}

/// <summary>
/// Weapon component for combat.
/// </summary>
public record struct Weapon(
    float Damage = 5f,
    DamageType DamageType = DamageType.Brute,
    float AttackCooldown = 0.5f,
    float ArmorPenetration = 0f,
    bool IsRanged = false
);

/// <summary>
/// Clothing component for wearable items.
/// </summary>
public record struct Clothing(
    ClothingSlot Slot = ClothingSlot.None,
    float BruteArmor = 0f,
    float BurnArmor = 0f,
    float ColdProtection = 0f,
    float HeatProtection = 0f
);

--- END: ./src/SpaceStation.Content/Components/Items/ItemComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/Power/PowerComponents.cs ---
namespace SpaceStation.Content.Components;

/// <summary>
/// Power distribution channels.
/// </summary>
public enum PowerChannel
{
    Equipment,
    Lighting,
    Environment
}

/// <summary>
/// Power consumer component.
/// </summary>
public record struct PowerConsumer(
    float PowerDraw = 100f,
    PowerChannel Channel = PowerChannel.Equipment,
    bool Powered = false,
    bool Enabled = true
);

/// <summary>
/// Power producer component.
/// </summary>
public record struct PowerProducer(
    float MaxOutput = 1000f,
    float CurrentOutput = 0f,
    bool Active = false
);

/// <summary>
/// Battery component for power storage.
/// </summary>
public record struct Battery(
    float MaxCharge = 10000f,
    float CurrentCharge = 10000f,
    float MaxChargeRate = 500f,
    float MaxDischargeRate = 1000f
)
{
    public readonly float ChargePercent => MaxCharge > 0 ? CurrentCharge / MaxCharge : 0f;
}

--- END: ./src/SpaceStation.Content/Components/Power/PowerComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/RenderComponents.cs ---
namespace SpaceStation.Content.Components;

/// <summary>
/// Rendering layer and plane from atoms.dm (layer, plane).
/// Controls the order in which entities are rendered.
/// </summary>
public record struct RenderLayer(
    /// <summary>
    /// Draw order within the same plane. Higher = drawn on top.
    /// Default layers: Turf=2.0, Mob=4.0, Item=3.0, Effect=5.0
    /// </summary>
    float Layer = 2.0f,
    
    /// <summary>
    /// Rendering plane. Higher planes are drawn on top regardless of layer.
    /// Default: 0 = Game plane, -100 = Background, 100 = HUD
    /// </summary>
    int Plane = 0
)
{
    // Common layer constants (from BYOND)
    public const float TurfLayer = 2.0f;
    public const float ObjLayer = 3.0f;
    public const float MobLayer = 4.0f;
    public const float FlyLayer = 5.0f;
    public const float EffectLayer = 5.0f;
    public const float AreaLayer = 1.0f;
    
    // Common plane constants
    public const int BackgroundPlane = -100;
    public const int GamePlane = 0;
    public const int LightingPlane = 50;
    public const int HudPlane = 100;
}

/// <summary>
/// Visibility and opacity from atoms.dm (opacity).
/// Controls whether this entity blocks line of sight.
/// </summary>
public record struct Visibility(
    /// <summary>Whether this entity blocks vision.</summary>
    bool Opaque = false,
    
    /// <summary>Visual transparency (0.0 = invisible, 1.0 = fully visible).</summary>
    float Alpha = 1.0f,
    
    /// <summary>See-invisible threshold for this entity.</summary>
    byte Invisibility = 0
);

/// <summary>
/// Light source from atoms.dm (light_range, light_power, light_color).
/// </summary>
public record struct LightSource(
    /// <summary>Range of light in tiles.</summary>
    float Range = 0f,
    
    /// <summary>Intensity of the light (0.0 to 1.0+).</summary>
    float Power = 1.0f,
    
    /// <summary>Light color as RGB bytes.</summary>
    byte R = 255,
    byte G = 255,
    byte B = 255,
    
    /// <summary>Whether the light is currently on.</summary>
    bool On = true
)
{
    public static readonly LightSource None = new(0f);
    
    public LightSource WithColor(byte r, byte g, byte b) => this with { R = r, G = g, B = b };
    public LightSource WithRange(float range) => this with { Range = range };
}

--- END: ./src/SpaceStation.Content/Components/RenderComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/TurfComponents.cs ---
namespace SpaceStation.Content.Components;

/// <summary>
/// Turf-specific data from turf.dm.
/// Represents floor/wall tile properties.
/// </summary>
public record struct Turf(
    /// <summary>
    /// Whether the turf's floor plating is intact.
    /// Affects what objects beneath are visible.
    /// </summary>
    bool Intact = true,
    
    /// <summary>
    /// Whether this turf blocks air flow.
    /// Used by atmos simulation.
    /// </summary>
    bool BlocksAir = false,
    
    /// <summary>
    /// Current temperature in Kelvin.
    /// T20C = 293.15K (room temperature)
    /// </summary>
    float Temperature = 293.15f,
    
    /// <summary>
    /// Maximum fire temperature this turf has been exposed to.
    /// Used for melting/destruction logic.
    /// </summary>
    float MaxFireTemperature = 0f,
    
    /// <summary>
    /// Whether this turf is holodeck-compatible.
    /// </summary>
    bool HolodeckCompatible = false
);

/// <summary>
/// Icon smoothing data from atoms.dm (smoothing_flags, smoothing_junction).
/// Used for auto-tiling walls and floors.
/// </summary>
public record struct Smoothing(
    /// <summary>Smoothing mode flags.</summary>
    SmoothingFlags Flags = SmoothingFlags.None,
    
    /// <summary>
    /// Current junction bitmask (0-255).
    /// Determines which neighbor connections exist.
    /// </summary>
    byte Junction = 0,
    
    /// <summary>Smoothing group ID this tile belongs to.</summary>
    ushort GroupId = 0
);

/// <summary>
/// Smoothing behavior flags.
/// </summary>
[Flags]
public enum SmoothingFlags : byte
{
    None = 0,
    
    /// <summary>Corner-based smoothing (RPGmaker style).</summary>
    Corners = 1 << 0,
    
    /// <summary>Bitmask-based smoothing (blob style).</summary>
    Bitmask = 1 << 1,
    
    /// <summary>Smooths with objects on the turf, not just turfs.</summary>
    SmoothObjects = 1 << 2,
    
    /// <summary>Currently queued for smoothing update.</summary>
    Queued = 1 << 3
}

/// <summary>
/// Space turf marker - turfs with this are open space.
/// </summary>
public record struct SpaceTurf;

/// <summary>
/// Simulated turf marker - turfs with atmos simulation.
/// </summary>
public record struct SimulatedTurf;

/// <summary>
/// Wall turf marker.
/// </summary>
public record struct WallTurf(
    /// <summary>Wall hardness for damage calculations.</summary>
    float Hardness = 50f,
    
    /// <summary>Whether this wall can be deconstructed.</summary>
    bool Deconstructable = true
);

/// <summary>
/// Floor turf marker.
/// </summary>
public record struct FloorTurf(
    /// <summary>Floor tile overlay ID (if tiled).</summary>
    ushort TileId = 0,
    
    /// <summary>Whether the floor uses burnt overlay.</summary>
    bool Burnt = false
);

--- END: ./src/SpaceStation.Content/Components/TurfComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/CollisionComponents.cs ---
namespace SpaceStation.Content.Components;

/// <summary>
/// Collision/density properties from atoms.dm.
/// Controls whether entities block movement.
/// </summary>
public record struct Collision(
    /// <summary>
    /// Whether this entity blocks movement (density).
    /// </summary>
    bool Dense = true,

    /// <summary>
    /// Pass flags for this entity - what can pass through it.
    /// </summary>
    PassFlags PassFlagsSelf = PassFlags.None,

    /// <summary>
    /// Whether thrown items can pass through this.
    /// </summary>
    bool CanPassThrow = false,

    /// <summary>
    /// Whether this is a border object (doors, windows).
    /// Border objects only block from certain directions.
    /// </summary>
    bool OnBorder = false
)
{
    /// <summary>Creates a non-blocking collision.</summary>
    public static Collision NonDense => new(Dense: false);

    /// <summary>Creates a dense collision that blocks everything.</summary>
    public static Collision Solid => new(Dense: true);
}

/// <summary>
/// Flags for what can pass through an entity.
/// From atoms.dm pass_flags_self.
/// </summary>
[Flags]
public enum PassFlags : ushort
{
    None = 0,

    /// <summary>Mobs can pass through.</summary>
    PassMob = 1 << 0,

    /// <summary>Items can pass through.</summary>
    PassItem = 1 << 1,

    /// <summary>Machines can pass through.</summary>
    PassMachine = 1 << 2,

    /// <summary>Thrown objects can pass through.</summary>
    PassThrow = 1 << 3,

    /// <summary>Projectiles can pass through.</summary>
    PassProjectile = 1 << 4,

    /// <summary>Glass-specific flag.</summary>
    PassGlass = 1 << 5,

    /// <summary>Grille-specific flag.</summary>
    PassGrille = 1 << 6,

    /// <summary>Table-specific flag.</summary>
    PassTable = 1 << 7,

    /// <summary>Everything passes.</summary>
    All = 0xFFFF
}

/// <summary>
/// Movement type flags for entities that are moving.
/// From atoms.dm movement_type.
/// </summary>
[Flags]
public enum MovementType : byte
{
    None = 0,

    /// <summary>Normal ground movement.</summary>
    Ground = 1 << 0,

    /// <summary>Flying movement (ignores gravity).</summary>
    Flying = 1 << 1,

    /// <summary>Floating movement (no gravity, no footsteps).</summary>
    Floating = 1 << 2,

    /// <summary>Phasing through walls (ghost mode).</summary>
    Phasing = 1 << 3,

    /// <summary>Ventcrawling movement.</summary>
    VentCrawling = 1 << 4
}

--- END: ./src/SpaceStation.Content/Components/CollisionComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/PlayerComponents.cs ---
namespace SpaceStation.Content.Components;

/// <summary>
/// Marks an entity as controlled by a player.
/// </summary>
public record struct Player(
    /// <summary>Client ID owning this entity.</summary>
    int ClientId = 0,

    /// <summary>Player's display name.</summary>
    string Name = "Unknown"
);

/// <summary>
/// Input state for a controllable entity.
/// Updated each tick from player input.
/// </summary>
public record struct InputState(
    float MoveX = 0f,
    float MoveY = 0f,
    bool Running = false,
    bool Interacting = false
);

--- END: ./src/SpaceStation.Content/Components/PlayerComponents.cs ---

--- START: ./src/SpaceStation.Content/Components/MoveTarget.cs ---
using System.Numerics;

namespace SpaceStation.Content.Components;

/// <summary>
/// Target tile for grid-based movement.
/// When present, entity is moving towards target tile.
/// </summary>
public record struct MoveTarget(
    /// <summary>Target tile X coordinate (integer)</summary>
    int TargetX,
    
    /// <summary>Target tile Y coordinate (integer)</summary>
    int TargetY,
    
    /// <summary>Movement progress from 0.0 to 1.0</summary>
    float Progress = 0f,
    
    /// <summary>Movement speed (tiles per second)</summary>
    float Speed = 4f
)
{
    /// <summary>Starting position when movement began.</summary>
    public Vector2 StartPosition { get; init; } = Vector2.Zero;
    
    /// <summary>Target position as Vector2.</summary>
    public readonly Vector2 TargetPosition => new(TargetX, TargetY);
    
    /// <summary>Is movement complete?</summary>
    public readonly bool IsComplete => Progress >= 1f;
}

--- END: ./src/SpaceStation.Content/Components/MoveTarget.cs ---

--- START: ./src/SpaceStation.Content/Systems/MovementSystem.cs ---
using System.Numerics;
using Arch.Core;
using Arch.Core.Extensions;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Components;

namespace SpaceStation.Content.Systems;

/// <summary>
/// System handling grid-based tile movement.
/// Uses MoveTarget for discrete tile-to-tile movement (SS13 style).
/// </summary>
public sealed class MovementSystem : BaseSystem
{
    public override int Priority => 10;

    // Entities currently moving (have MoveTarget)
    private static readonly QueryDescription MovingQuery = new QueryDescription()
        .WithAll<Transform, MoveTarget>();
    
    // Entities with input that might want to start moving
    private static readonly QueryDescription InputQuery = new QueryDescription()
        .WithAll<Transform, Physics, InputState>()
        .WithNone<MoveTarget>();

    /// <summary>
    /// Optional collision checker callback.
    /// Returns true if tile is passable.
    /// </summary>
    public Func<int, int, bool>? IsPassable { get; set; }

    public override void Update(float deltaTime, World world)
    {
        // Process entities currently moving
        ProcessMovingEntities(world, deltaTime);
        
        // Process input for entities that can start moving
        ProcessInputEntities(world);
    }
    
    private void ProcessMovingEntities(World world, float deltaTime)
    {
        var toComplete = new List<Entity>();
        
        world.Query(in MovingQuery, (Entity entity, ref Transform transform, ref MoveTarget target) =>
        {
            // Advance progress
            target.Progress += target.Speed * deltaTime;
            
            if (target.Progress >= 1f)
            {
                // Snap to exact tile position
                transform.Position = target.TargetPosition;
                toComplete.Add(entity);
            }
            else
            {
                // Lerp towards target
                transform.Position = Vector2.Lerp(target.StartPosition, target.TargetPosition, target.Progress);
            }
        });
        
        // Remove MoveTarget from completed entities
        foreach (var entity in toComplete)
        {
            if (world.IsAlive(entity) && world.Has<MoveTarget>(entity))
            {
                world.Remove<MoveTarget>(entity);
            }
        }
    }
    
    private void ProcessInputEntities(World world)
    {
        var toStartMoving = new List<(Entity entity, int dx, int dy)>();
        
        world.Query(in InputQuery, (Entity entity, ref Transform transform, ref Physics physics, ref InputState input) =>
        {
            if (physics.Anchored)
                return;
            
            // Check for movement input
            int dx = 0, dy = 0;
            
            if (input.MoveX < -0.5f) dx = -1;
            else if (input.MoveX > 0.5f) dx = 1;
            
            if (input.MoveY < -0.5f) dy = -1;
            else if (input.MoveY > 0.5f) dy = 1;
            
            // Only allow cardinal movement (no diagonals in SS13)
            if (dx != 0 && dy != 0)
            {
                // Prefer horizontal movement
                dy = 0;
            }
            
            if (dx != 0 || dy != 0)
            {
                toStartMoving.Add((entity, dx, dy));
            }
        });
        
        // Start movement for entities
        foreach (var (entity, dx, dy) in toStartMoving)
        {
            if (!world.IsAlive(entity)) continue;
            
            var transform = world.Get<Transform>(entity);
            var physics = world.Get<Physics>(entity);
            
            // Calculate target tile
            int currentX = (int)MathF.Round(transform.Position.X);
            int currentY = (int)MathF.Round(transform.Position.Y);
            int targetX = currentX + dx;
            int targetY = currentY + dy;
            
            // Check collision
            bool canMove = IsPassable?.Invoke(targetX, targetY) ?? true;
            
            if (canMove)
            {
                // Start moving
                var moveTarget = new MoveTarget(targetX, targetY, 0f, physics.MoveSpeed)
                {
                    StartPosition = transform.Position
                };
                world.Add(entity, moveTarget);
            }
        }
    }
    
    /// <summary>
    /// Instantly starts movement for an entity (for testing/direct control).
    /// </summary>
    public static void StartMove(World world, Entity entity, int dx, int dy)
    {
        if (!world.IsAlive(entity)) return;
        if (!world.Has<Transform>(entity)) return;
        if (world.Has<MoveTarget>(entity)) return; // Already moving
        
        var transform = world.Get<Transform>(entity);
        float speed = world.Has<Physics>(entity) ? world.Get<Physics>(entity).MoveSpeed : 4f;
        
        int currentX = (int)MathF.Round(transform.Position.X);
        int currentY = (int)MathF.Round(transform.Position.Y);
        
        var target = new MoveTarget(currentX + dx, currentY + dy, 0f, speed)
        {
            StartPosition = transform.Position
        };
        world.Add(entity, target);
    }
}

--- END: ./src/SpaceStation.Content/Systems/MovementSystem.cs ---

--- START: ./src/SpaceStation.Content/Systems/HealthSystem.cs ---
using Arch.Core;
using Arch.Core.Extensions;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Components;
using SpaceStation.Shared.Enums;
using SpaceStation.Shared.Constants;

namespace SpaceStation.Content.Systems;

/// <summary>
/// System managing entity health and state transitions.
/// </summary>
public sealed class HealthSystem : BaseSystem
{
    public override int Priority => 20;

    private static readonly QueryDescription Query = new QueryDescription()
        .WithAll<Health, Damageable>();

    public override void Update(float deltaTime, World world)
    {
        world.Query(in Query, (ref Health health, ref Damageable damageable) =>
        {
            // Calculate health from damage
            health.CurrentHealth = health.MaxHealth - damageable.TotalDamage;

            // Update mob state based on health
            UpdateMobState(ref health);
        });
    }

    private static void UpdateMobState(ref Health health)
    {
        if (health.State == MobState.Gibbed)
            return; // Gibbed is permanent

        if (health.CurrentHealth <= GameConstants.DeathThreshold)
        {
            health.State = MobState.Dead;
        }
        else if (health.CurrentHealth <= GameConstants.CriticalHealthThreshold)
        {
            health.State = MobState.Critical;
        }
        else
        {
            health.State = MobState.Alive;
        }
    }
}

--- END: ./src/SpaceStation.Content/Systems/HealthSystem.cs ---

--- START: ./src/SpaceStation.Content/Systems/AtmosSystem.cs ---
using Arch.Core;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Components;
using SpaceStation.Shared.Constants;

namespace SpaceStation.Content.Systems;

/// <summary>
/// System simulating atmospheric gas flow and reactions.
/// Similar to SS13's SSair subsystem.
/// </summary>
public sealed class AtmosSystem : BaseSystem
{
    public override int Priority => 30;

    private float _tickAccumulator = 0f;

    public override void Update(float deltaTime, World world)
    {
        _tickAccumulator += deltaTime;

        // Run atmos at its own tick rate
        if (_tickAccumulator < AtmosConstants.AtmosTickRate)
            return;

        _tickAccumulator -= AtmosConstants.AtmosTickRate;

        ProcessAtmosphere(world);
    }

    private void ProcessAtmosphere(World world)
    {
        // TODO: Implement gas flow simulation
        // This would include:
        // - Gas equalization between adjacent tiles
        // - Space exposure (venting)
        // - Temperature equalization
        // - Gas reactions (plasma fire, etc.)
    }

    /// <summary>
    /// Checks if an atmosphere is breathable.
    /// </summary>
    public static bool IsBreathable(in Atmosphere atmos)
    {
        var totalMoles = atmos.TotalMoles;
        if (totalMoles <= 0) return false;

        var oxygenPercent = (atmos.Oxygen / totalMoles) * 100f;
        var pressure = atmos.Pressure;

        return oxygenPercent >= AtmosConstants.MinBreathableOxygen &&
               oxygenPercent <= AtmosConstants.ToxicOxygenThreshold &&
               pressure >= AtmosConstants.HazardLowPressure &&
               pressure <= AtmosConstants.HazardHighPressure;
    }
}

--- END: ./src/SpaceStation.Content/Systems/AtmosSystem.cs ---

--- START: ./src/SpaceStation.Content/Systems/PowerSystem.cs ---
using Arch.Core;
using Arch.Core.Extensions;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Components;

namespace SpaceStation.Content.Systems;

/// <summary>
/// System managing power distribution.
/// Similar to SS13's SSpower subsystem.
/// </summary>
public sealed class PowerSystem : BaseSystem
{
    public override int Priority => 25;

    private static readonly QueryDescription ProducerQuery = new QueryDescription()
        .WithAll<PowerProducer>();

    private static readonly QueryDescription ConsumerQuery = new QueryDescription()
        .WithAll<PowerConsumer>();

    private static readonly QueryDescription BatteryQuery = new QueryDescription()
        .WithAll<Battery>();

    public override void Update(float deltaTime, World world)
    {
        // Calculate total power supply
        float totalSupply = 0f;
        world.Query(in ProducerQuery, (ref PowerProducer producer) =>
        {
            if (producer.Active)
            {
                totalSupply += producer.CurrentOutput;
            }
        });

        // Calculate total demand
        float totalDemand = 0f;
        world.Query(in ConsumerQuery, (ref PowerConsumer consumer) =>
        {
            if (consumer.Enabled)
            {
                totalDemand += consumer.PowerDraw;
            }
        });

        // Distribute power to consumers
        bool powered = totalSupply >= totalDemand;
        world.Query(in ConsumerQuery, (ref PowerConsumer consumer) =>
        {
            consumer.Powered = consumer.Enabled && powered;
        });

        // Update batteries
        float surplus = totalSupply - totalDemand;
        world.Query(in BatteryQuery, (ref Battery battery) =>
        {
            if (surplus > 0)
            {
                // Charge batteries with surplus
                var chargeAmount = MathF.Min(surplus, battery.MaxChargeRate * deltaTime);
                battery.CurrentCharge = MathF.Min(battery.MaxCharge, battery.CurrentCharge + chargeAmount);
            }
            else if (surplus < 0)
            {
                // Drain batteries to cover deficit
                var drainAmount = MathF.Min(-surplus, battery.MaxDischargeRate * deltaTime);
                battery.CurrentCharge = MathF.Max(0, battery.CurrentCharge - drainAmount);
            }
        });
    }
}

--- END: ./src/SpaceStation.Content/Systems/PowerSystem.cs ---

--- START: ./src/SpaceStation.Server/Program.cs ---
﻿using Arch.Core;
using Arch.Core.Extensions;
using LiteNetLib;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Systems;
using SpaceStation.Content.Components;
using SpaceStation.Server.Network;
using SpaceStation.Shared.Network;
using SpaceStation.Shared.Network.Packets;
using SpaceStation.Shared.Prototypes;

namespace SpaceStation.Server;

/// <summary>
/// Main server class for Space Station 13 remake.
/// </summary>
public sealed class GameServer : IDisposable
{
    private readonly World _world;
    private readonly SystemManager _systems;
    private readonly ServerNetworkManager _network;

    // Data-driven content
    private readonly PrototypeManager _prototypes;
    private readonly EntityFactory _entityFactory;

    private bool _running;
    private uint _currentTick;

    // Entity ID and sprite tracking for network sync
    private readonly Dictionary<Entity, (int NetId, string SpriteId)> _entityRegistry = new();
    private readonly Dictionary<int, Entity> _netIdToEntity = new();
    private int _nextNetworkId = 1;

    // Player sessions: ClientId -> Player Entity
    private readonly Dictionary<int, Entity> _playerSessions = new();

    // Query for entities with Transform (all syncable entities)
    private static readonly QueryDescription SyncableQuery = new QueryDescription()
        .WithAll<Transform>();

    // Query for player-controlled entities
    private static readonly QueryDescription PlayerQuery = new QueryDescription()
        .WithAll<Player, Transform, Physics>();

    public GameServer()
    {
        _world = World.Create();
        _systems = new SystemManager(_world);
        _network = new ServerNetworkManager();

        // Initialize prototype system
        _prototypes = new PrototypeManager();
        _entityFactory = new EntityFactory(_prototypes);

        // Hook entity spawning to network registration
        _entityFactory.OnEntitySpawned += RegisterNetworkEntity;

        // Register core systems
        _systems.RegisterSystem<MovementSystem>();
        _systems.RegisterSystem<HealthSystem>();
        _systems.RegisterSystem<PowerSystem>();
        _systems.RegisterSystem<AtmosSystem>();

        // Subscribe to network events
        _network.OnClientConnected += OnClientConnected;
        _network.OnClientDisconnected += OnClientDisconnected;
        _network.OnDataReceived += OnDataReceived;
    }

    /// <summary>
    /// Initializes and starts the server.
    /// </summary>
    public void Start()
    {
        Console.WriteLine("╔════════════════════════════════════════╗");
        Console.WriteLine("║     Space Station 13 - C# Remake       ║");
        Console.WriteLine("║          SERVER v0.4.0-DATA            ║");
        Console.WriteLine("╚════════════════════════════════════════╝");
        Console.WriteLine();

        // Load prototypes
        LoadPrototypes();

        _systems.Initialize();

        // Create initial game entities
        CreateGameEntities();

        // Start network
        if (!_network.Start())
        {
            Console.WriteLine("[Server] Failed to start network, exiting.");
            return;
        }

        Console.WriteLine("[Server] Systems initialized");
        Console.WriteLine($"[Server] Tick rate: {NetworkConstants.TickRate} ticks/second");
        Console.WriteLine($"[Server] Entities: {_world.Size}");
        Console.WriteLine("[Server] Starting game loop...");
        Console.WriteLine("[Server] Press Ctrl+C to stop.");
        Console.WriteLine();

        _running = true;
        RunGameLoop();
    }

    private void LoadPrototypes()
    {
        // Try multiple paths to find prototypes
        var paths = new[]
        {
            Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "..", "..", "Resources", "Prototypes"),
            "Resources/Prototypes",
            "../Resources/Prototypes"
        };

        foreach (var path in paths)
        {
            if (Directory.Exists(path))
            {
                _prototypes.LoadDirectory(path);
                return;
            }
        }

        Console.WriteLine("[Server] WARNING: Prototypes directory not found!");
    }

    private void CreateGameEntities()
    {
        var pos = System.Numerics.Vector2.Zero;

        // Create floor tiles using prototype
        for (int x = 0; x < 15; x++)
        {
            for (int y = 0; y < 15; y++)
            {
                pos = new System.Numerics.Vector2(x, y);
                _entityFactory.Spawn(_world, "Floor", pos);
            }
        }

        // Create walls around the edge
        for (int i = 0; i < 15; i++)
        {
            // Top and bottom walls
            _entityFactory.Spawn(_world, "Wall", new System.Numerics.Vector2(i, -1));
            _entityFactory.Spawn(_world, "Wall", new System.Numerics.Vector2(i, 15));
        }

        // Create some crew members
        for (int i = 0; i < 5; i++)
        {
            pos = new System.Numerics.Vector2(5 + i * 2, 7);
            _entityFactory.Spawn(_world, "Human", pos);
        }

        // Create power infrastructure
        _entityFactory.Spawn(_world, "Generator", new System.Numerics.Vector2(2, 2));

        // Create some items
        _entityFactory.Spawn(_world, "Toolbox", new System.Numerics.Vector2(8, 3));
        _entityFactory.Spawn(_world, "Wrench", new System.Numerics.Vector2(9, 3));

        Console.WriteLine($"[Server] Created {_entityRegistry.Count} network entities from prototypes");
    }

    private void RegisterNetworkEntity(Entity entity, string spriteId)
    {
        var netId = _nextNetworkId++;
        _entityRegistry[entity] = (netId, spriteId);
        _netIdToEntity[netId] = entity;
    }

    private void OnClientConnected(int clientId, NetPeer peer)
    {
        Console.WriteLine($"[Server] Client {clientId} connected, spawning player...");

        // Spawn player entity
        var spawnPos = new System.Numerics.Vector2(7, 7); // Center of map
        var playerEntity = _entityFactory.Spawn(_world, "Human", spawnPos);

        if (playerEntity.HasValue)
        {
            var entity = playerEntity.Value;

            // Add Player component
            _world.Add(entity, new Player(clientId, $"Player {clientId}"));
            _world.Add(entity, new InputState());

            // Track session
            _playerSessions[clientId] = entity;

            // Get network ID
            if (_entityRegistry.TryGetValue(entity, out var reg))
            {
                // Tell client which entity is theirs
                var packet = new PlayerSpawnedPacket { EntityId = reg.NetId };
                var data = PacketSerializer.Serialize(packet);
                _network.SendTo(clientId, data, DeliveryMethod.ReliableOrdered);

                Console.WriteLine($"[Server] Spawned player entity {reg.NetId} for client {clientId}");
            }
        }

        // Send full world snapshot
        var snapshot = BuildWorldSnapshot();
        var snapshotData = PacketSerializer.Serialize(snapshot);
        _network.SendTo(clientId, snapshotData, DeliveryMethod.ReliableOrdered);
    }

    private void OnClientDisconnected(int clientId)
    {
        Console.WriteLine($"[Server] Client {clientId} disconnected");

        // Remove player entity
        if (_playerSessions.TryGetValue(clientId, out var entity))
        {
            if (_world.IsAlive(entity))
            {
                // Unregister from network
                if (_entityRegistry.TryGetValue(entity, out var reg))
                {
                    _netIdToEntity.Remove(reg.NetId);
                    _entityRegistry.Remove(entity);
                }

                _world.Destroy(entity);
            }
            _playerSessions.Remove(clientId);
        }
    }

    private void OnDataReceived(int clientId, byte[] data)
    {
        try
        {
            // Try to deserialize as PlayerInputPacket
            var inputPacket = PacketSerializer.Deserialize<PlayerInputPacket>(data);
            if (inputPacket != null)
            {
                HandlePlayerInput(clientId, inputPacket);
            }
        }
        catch
        {
            // Unknown packet, ignore
        }
    }

    private void HandlePlayerInput(int clientId, PlayerInputPacket input)
    {
        if (!_playerSessions.TryGetValue(clientId, out var entity))
            return;

        if (!_world.IsAlive(entity))
            return;

        // Update InputState
        if (_world.Has<InputState>(entity))
        {
            _world.Set(entity, new InputState(input.MoveX, input.MoveY));
        }

        // Apply velocity directly to Physics
        if (_world.Has<Physics>(entity))
        {
            ref var physics = ref _world.Get<Physics>(entity);
            var moveSpeed = physics.MoveSpeed;
            var velocity = new System.Numerics.Vector2(
                input.MoveX * moveSpeed,
                input.MoveY * moveSpeed
            );
            physics = physics with { Velocity = velocity };
        }
    }

    /// <summary>
    /// Stops the server.
    /// </summary>
    public void Stop()
    {
        _running = false;
        Console.WriteLine("[Server] Shutting down...");
    }

    private void RunGameLoop()
    {
        var tickDuration = TimeSpan.FromSeconds(1.0 / NetworkConstants.TickRate);
        var lastTick = DateTime.UtcNow;
        var lastStatusUpdate = DateTime.UtcNow;

        while (_running)
        {
            var now = DateTime.UtcNow;
            var deltaTime = (float)(now - lastTick).TotalSeconds;
            lastTick = now;

            // Poll network events
            _network.PollEvents();

            // Update all systems
            _systems.Update(deltaTime);

            _currentTick++;

            // Broadcast world state to all clients
            if (_network.ClientCount > 0)
            {
                BroadcastWorldState();
            }

            // Print status every 5 seconds
            if ((now - lastStatusUpdate).TotalSeconds >= 5)
            {
                Console.WriteLine($"[Server] Tick {_currentTick}, Entities: {_world.Size}, Clients: {_network.ClientCount}");
                lastStatusUpdate = now;
            }

            // Sleep until next tick
            var elapsed = DateTime.UtcNow - now;
            var sleepTime = tickDuration - elapsed;
            if (sleepTime > TimeSpan.Zero)
            {
                Thread.Sleep(sleepTime);
            }
        }
    }

    private WorldSnapshotPacket BuildWorldSnapshot()
    {
        var entities = new List<NetworkEntity>();

        _world.Query(in SyncableQuery, (Entity entity, ref Transform transform) =>
        {
            if (!_entityRegistry.TryGetValue(entity, out var registration))
                return;

            var netEntity = new NetworkEntity
            {
                EntityId = registration.NetId,
                Transform = new NetworkTransform(
                    transform.Position.X,
                    transform.Position.Y,
                    transform.Rotation,
                    transform.ZLevel
                ),
                // Include sprite reference
                Sprite = new NetworkSprite
                {
                    TextureId = registration.SpriteId,
                    TintR = 255,
                    TintG = 255,
                    TintB = 255,
                    TintA = 255,
                    Scale = 1f
                }
            };

            // Add optional components
            if (_world.Has<Physics>(entity))
            {
                var physics = _world.Get<Physics>(entity);
                netEntity.Physics = new NetworkPhysics
                {
                    VelocityX = physics.Velocity.X,
                    VelocityY = physics.Velocity.Y,
                    MoveSpeed = physics.MoveSpeed,
                    Dense = physics.Dense,
                    Anchored = physics.Anchored
                };
            }

            if (_world.Has<Health>(entity))
            {
                var health = _world.Get<Health>(entity);
                netEntity.Health = new NetworkHealth
                {
                    MaxHealth = health.MaxHealth,
                    CurrentHealth = health.CurrentHealth,
                    State = (byte)health.State
                };
            }

            entities.Add(netEntity);
        });

        return new WorldSnapshotPacket
        {
            Header = new PacketHeader
            {
                Type = PacketType.WorldSnapshot,
                Tick = _currentTick,
                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
            },
            Entities = entities.ToArray(),
            PlayerCount = _network.ClientCount
        };
    }

    private void BroadcastWorldState()
    {
        var snapshot = BuildWorldSnapshot();
        var data = PacketSerializer.Serialize(snapshot);
        // Use ReliableUnordered - supports fragmentation for large packets
        _network.Broadcast(data, DeliveryMethod.ReliableUnordered);
    }

    public void Dispose()
    {
        _running = false;
        _network.Dispose();
        _systems.Dispose();
        _world.Dispose();
    }
}

/// <summary>
/// Server entry point.
/// </summary>
public static class Program
{
    public static void Main(string[] args)
    {
        using var server = new GameServer();

        // Handle Ctrl+C for graceful shutdown
        Console.CancelKeyPress += (sender, e) =>
        {
            e.Cancel = true;
            server.Stop();
        };

        server.Start();

        Console.WriteLine("[Server] Shutdown complete.");
    }
}

--- END: ./src/SpaceStation.Server/Program.cs ---

--- START: ./src/SpaceStation.Server/obj/Debug/net9.0/SpaceStation.Server.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Server/obj/Debug/net9.0/SpaceStation.Server.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Server/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Server/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Server/obj/Debug/net9.0/SpaceStation.Server.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Server")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Server")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Server")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Server/obj/Debug/net9.0/SpaceStation.Server.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Server/Network/ServerNetworkManager.cs ---
using LiteNetLib;
using LiteNetLib.Utils;
using SpaceStation.Shared.Network;
using SpaceStation.Shared.Network.Packets;

namespace SpaceStation.Server.Network;

/// <summary>
/// Server-side network manager handling client connections and packet broadcasting.
/// </summary>
public sealed class ServerNetworkManager : INetEventListener, IDisposable
{
    private readonly NetManager _netManager;
    private readonly Dictionary<int, NetPeer> _clients = new();
    private int _nextClientId = 1;

    public bool IsRunning => _netManager.IsRunning;
    public int ClientCount => _clients.Count;

    /// <summary>Event when a client connects.</summary>
    public event Action<int, NetPeer>? OnClientConnected;

    /// <summary>Event when a client disconnects.</summary>
    public event Action<int>? OnClientDisconnected;

    /// <summary>Event when data is received from a client.</summary>
    public event Action<int, byte[]>? OnDataReceived;

    public ServerNetworkManager()
    {
        _netManager = new NetManager(this)
        {
            AutoRecycle = true,
            DisconnectTimeout = NetworkConstants.DisconnectTimeout,
            PingInterval = NetworkConstants.PingInterval,
            UnconnectedMessagesEnabled = false
        };
    }

    /// <summary>
    /// Starts the server on the specified port.
    /// </summary>
    public bool Start(int port = NetworkConstants.DefaultPort)
    {
        var result = _netManager.Start(port);
        if (result)
        {
            Console.WriteLine($"[Network] Server started on port {port}");
        }
        else
        {
            Console.WriteLine($"[Network] Failed to start server on port {port}");
        }
        return result;
    }

    /// <summary>
    /// Stops the server.
    /// </summary>
    public void Stop()
    {
        _netManager.Stop();
        _clients.Clear();
        Console.WriteLine("[Network] Server stopped");
    }

    /// <summary>
    /// Polls network events. Should be called every frame/tick.
    /// </summary>
    public void PollEvents()
    {
        _netManager.PollEvents();
    }

    /// <summary>
    /// Broadcasts data to all connected clients.
    /// </summary>
    public void Broadcast(byte[] data, DeliveryMethod deliveryMethod = DeliveryMethod.ReliableOrdered)
    {
        foreach (var client in _clients.Values)
        {
            client.Send(data, deliveryMethod);
        }
    }

    /// <summary>
    /// Sends data to a specific client.
    /// </summary>
    public void SendTo(int clientId, byte[] data, DeliveryMethod deliveryMethod = DeliveryMethod.ReliableOrdered)
    {
        if (_clients.TryGetValue(clientId, out var peer))
        {
            peer.Send(data, deliveryMethod);
        }
    }

    /// <summary>
    /// Disconnects a specific client.
    /// </summary>
    public void DisconnectClient(int clientId)
    {
        if (_clients.TryGetValue(clientId, out var peer))
        {
            peer.Disconnect();
        }
    }

    // INetEventListener implementation

    public void OnConnectionRequest(ConnectionRequest request)
    {
        var key = request.Data.GetString();
        if (key == NetworkConstants.ConnectionKey && _clients.Count < NetworkConstants.MaxPlayers)
        {
            request.Accept();
            Console.WriteLine($"[Network] Connection request accepted from {request.RemoteEndPoint}");
        }
        else
        {
            request.Reject();
            Console.WriteLine($"[Network] Connection request rejected from {request.RemoteEndPoint}");
        }
    }

    public void OnPeerConnected(NetPeer peer)
    {
        var clientId = _nextClientId++;
        _clients[clientId] = peer;

        Console.WriteLine($"[Network] Client {clientId} connected from {peer.Address}:{peer.Port}");

        // Send connection accepted
        var acceptPacket = new ConnectionAcceptedPacket
        {
            ClientId = clientId,
            TickRate = NetworkConstants.TickRate
        };
        var data = PacketSerializer.Serialize(acceptPacket);
        peer.Send(data, DeliveryMethod.ReliableOrdered);

        OnClientConnected?.Invoke(clientId, peer);
    }

    public void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
    {
        var clientId = _clients.FirstOrDefault(x => x.Value == peer).Key;
        if (clientId != 0)
        {
            _clients.Remove(clientId);
            Console.WriteLine($"[Network] Client {clientId} disconnected: {disconnectInfo.Reason}");
            OnClientDisconnected?.Invoke(clientId);
        }
    }

    public void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
    {
        var clientId = _clients.FirstOrDefault(x => x.Value == peer).Key;
        if (clientId != 0)
        {
            var data = new byte[reader.AvailableBytes];
            reader.GetBytes(data, data.Length);
            OnDataReceived?.Invoke(clientId, data);
        }
    }

    public void OnNetworkError(System.Net.IPEndPoint endPoint, System.Net.Sockets.SocketError socketError)
    {
        Console.WriteLine($"[Network] Error from {endPoint}: {socketError}");
    }

    public void OnNetworkReceiveUnconnected(System.Net.IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
    {
        // Not used
    }

    public void OnNetworkLatencyUpdate(NetPeer peer, int latency)
    {
        // Could be used for ping display
    }

    public void Dispose()
    {
        Stop();
    }
}

--- END: ./src/SpaceStation.Server/Network/ServerNetworkManager.cs ---

--- START: ./src/SpaceStation.Server/EntityFactory.cs ---
using System.Numerics;
using System.Reflection;
using System.Text.Json;
using Arch.Core;
using SpaceStation.Content.Components;
using SpaceStation.Shared.Prototypes;

namespace SpaceStation.Server;

/// <summary>
/// Factory for creating ECS entities from JSON prototypes.
/// Uses reflection to map component names to C# structs.
/// </summary>
public sealed class EntityFactory
{
    private readonly PrototypeManager _prototypes;
    private readonly Dictionary<string, Type> _componentTypes = new(StringComparer.OrdinalIgnoreCase);

    // Callback for registering spawned entities with network sync
    public Action<Entity, string>? OnEntitySpawned { get; set; }

    public EntityFactory(PrototypeManager prototypes)
    {
        _prototypes = prototypes;
        DiscoverComponents();
    }

    /// <summary>
    /// Discovers all component types from SpaceStation.Content.Components namespace.
    /// </summary>
    private void DiscoverComponents()
    {
        var contentAssembly = typeof(Transform).Assembly;
        var componentTypes = contentAssembly.GetTypes()
            .Where(t => t.IsValueType && t.Namespace?.Contains("Components") == true);

        foreach (var type in componentTypes)
        {
            _componentTypes[type.Name] = type;
        }

        Console.WriteLine($"[EntityFactory] Discovered {_componentTypes.Count} component types");
    }

    /// <summary>
    /// Spawns an entity from a prototype at the given position.
    /// </summary>
    /// <param name="world">The ECS world.</param>
    /// <param name="prototypeId">Prototype ID to spawn.</param>
    /// <param name="position">World position.</param>
    /// <returns>The created entity, or null if prototype not found.</returns>
    public Entity? Spawn(World world, string prototypeId, Vector2 position)
    {
        if (!_prototypes.TryGet<EntityPrototype>(prototypeId, out var prototype) || prototype == null)
        {
            Console.WriteLine($"[EntityFactory] Prototype not found: {prototypeId}");
            return null;
        }

        return SpawnFromPrototype(world, prototype, position);
    }

    /// <summary>
    /// Spawns an entity from a prototype object.
    /// </summary>
    public Entity SpawnFromPrototype(World world, EntityPrototype prototype, Vector2 position)
    {
        // Always create with Transform
        var transform = new Transform(position, 0f, 0);

        // Collect all components to add
        var components = new List<object> { transform };

        foreach (var compData in prototype.Components)
        {
            var component = CreateComponent(compData);
            if (component != null)
            {
                components.Add(component);
            }
        }

        // Create entity with all components
        var entity = CreateEntityWithComponents(world, components);

        // Notify listeners (for network registration)
        OnEntitySpawned?.Invoke(entity, prototype.Sprite ?? prototype.ID);

        return entity;
    }

    /// <summary>
    /// Creates a component instance from ComponentData.
    /// </summary>
    private object? CreateComponent(ComponentData data)
    {
        if (!_componentTypes.TryGetValue(data.Type, out var componentType))
        {
            Console.WriteLine($"[EntityFactory] Unknown component type: {data.Type}");
            return null;
        }

        try
        {
            // Create instance using constructor with matching parameters
            var instance = CreateComponentInstance(componentType, data.Data);
            return instance;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[EntityFactory] Failed to create component {data.Type}: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Creates a component instance, matching JSON data to constructor parameters.
    /// </summary>
    private object CreateComponentInstance(Type type, Dictionary<string, object> data)
    {
        // Get the primary constructor (record structs have one)
        var constructors = type.GetConstructors();

        // Try to find a constructor that matches the data
        foreach (var ctor in constructors.OrderByDescending(c => c.GetParameters().Length))
        {
            var parameters = ctor.GetParameters();
            var args = new object?[parameters.Length];
            var matched = true;

            for (int i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];
                var value = GetParameterValue(param, data);

                if (value == null && !param.HasDefaultValue)
                {
                    matched = false;
                    break;
                }

                args[i] = value ?? param.DefaultValue;
            }

            if (matched)
            {
                return ctor.Invoke(args)!;
            }
        }

        // Fallback: create default instance and set properties
        var instance = Activator.CreateInstance(type)!;
        SetProperties(instance, data);
        return instance;
    }

    /// <summary>
    /// Gets a parameter value from JSON data.
    /// </summary>
    private object? GetParameterValue(ParameterInfo param, Dictionary<string, object> data)
    {
        // Try exact match first
        if (data.TryGetValue(param.Name!, out var value))
        {
            return ConvertValue(value, param.ParameterType);
        }

        // Try case-insensitive match
        var key = data.Keys.FirstOrDefault(k =>
            string.Equals(k, param.Name, StringComparison.OrdinalIgnoreCase));

        if (key != null)
        {
            return ConvertValue(data[key], param.ParameterType);
        }

        return null;
    }

    /// <summary>
    /// Sets properties on an object from JSON data.
    /// </summary>
    private void SetProperties(object instance, Dictionary<string, object> data)
    {
        var type = instance.GetType();

        foreach (var (key, value) in data)
        {
            var prop = type.GetProperty(key, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            if (prop != null && prop.CanWrite)
            {
                var converted = ConvertValue(value, prop.PropertyType);
                prop.SetValue(instance, converted);
            }
        }
    }

    /// <summary>
    /// Converts a JSON value to the target type.
    /// </summary>
    private object? ConvertValue(object value, Type targetType)
    {
        if (value == null)
            return null;

        // Handle JsonElement (from System.Text.Json)
        if (value is JsonElement element)
        {
            return ConvertJsonElement(element, targetType);
        }

        // Direct type match
        if (targetType.IsAssignableFrom(value.GetType()))
        {
            return value;
        }

        // Numeric conversions
        if (targetType == typeof(float))
            return Convert.ToSingle(value);
        if (targetType == typeof(int))
            return Convert.ToInt32(value);
        if (targetType == typeof(double))
            return Convert.ToDouble(value);
        if (targetType == typeof(bool))
            return Convert.ToBoolean(value);
        if (targetType == typeof(byte))
            return Convert.ToByte(value);
        if (targetType == typeof(ushort))
            return Convert.ToUInt16(value);

        // Vector2
        if (targetType == typeof(Vector2) && value is JsonElement vecElement)
        {
            var x = vecElement.GetProperty("X").GetSingle();
            var y = vecElement.GetProperty("Y").GetSingle();
            return new Vector2(x, y);
        }

        // Enum
        if (targetType.IsEnum)
        {
            return Enum.Parse(targetType, value.ToString()!, ignoreCase: true);
        }

        return Convert.ChangeType(value, targetType);
    }

    /// <summary>
    /// Converts a JsonElement to the target type.
    /// </summary>
    private object? ConvertJsonElement(JsonElement element, Type targetType)
    {
        return element.ValueKind switch
        {
            JsonValueKind.Number when targetType == typeof(float) => element.GetSingle(),
            JsonValueKind.Number when targetType == typeof(int) => element.GetInt32(),
            JsonValueKind.Number when targetType == typeof(double) => element.GetDouble(),
            JsonValueKind.Number when targetType == typeof(byte) => (byte)element.GetInt32(),
            JsonValueKind.Number when targetType == typeof(ushort) => (ushort)element.GetInt32(),
            JsonValueKind.Number => element.GetSingle(), // Default to float
            JsonValueKind.True => true,
            JsonValueKind.False => false,
            JsonValueKind.String when targetType.IsEnum => Enum.Parse(targetType, element.GetString()!, true),
            JsonValueKind.String => element.GetString(),
            _ => null
        };
    }

    /// <summary>
    /// Creates an entity with a dynamic list of components.
    /// Uses typed dispatch for common cases.
    /// </summary>
    private Entity CreateEntityWithComponents(World world, List<object> components)
    {
        // First component is always Transform
        var transform = (Transform)components[0];

        if (components.Count == 1)
        {
            return world.Create(transform);
        }

        // Create with transform first, then add other components
        var entity = world.Create(transform);

        for (int i = 1; i < components.Count; i++)
        {
            AddComponentByType(world, entity, components[i]);
        }

        return entity;
    }

    /// <summary>
    /// Adds a component to an entity using type-specific dispatch.
    /// </summary>
    private void AddComponentByType(World world, Entity entity, object component)
    {
        switch (component)
        {
            case Physics p:
                world.Add(entity, p);
                break;
            case Health h:
                world.Add(entity, h);
                break;
            case Damageable d:
                world.Add(entity, d);
                break;
            case Atmosphere a:
                world.Add(entity, a);
                break;
            case PowerProducer pp:
                world.Add(entity, pp);
                break;
            case PowerConsumer pc:
                world.Add(entity, pc);
                break;
            case Collision c:
                world.Add(entity, c);
                break;
            case RenderLayer rl:
                world.Add(entity, rl);
                break;
            case Visibility v:
                world.Add(entity, v);
                break;
            case Turf t:
                world.Add(entity, t);
                break;
            case Player pl:
                world.Add(entity, pl);
                break;
            case InputState inp:
                world.Add(entity, inp);
                break;
            default:
                // Fallback to reflection for unknown types
                AddComponentDynamic(world, entity, component);
                break;
        }
    }

    private void AddComponentDynamic(World world, Entity entity, object component)
    {
        // Use reflection to call Add<T>
        var method = typeof(Arch.Core.Extensions.EntityExtensions)
            .GetMethods()
            .FirstOrDefault(m => m.Name == "Add" && m.GetParameters().Length == 2);

        if (method != null)
        {
            var generic = method.MakeGenericMethod(component.GetType());
            generic.Invoke(null, new object[] { entity, component });
        }
    }
}

--- END: ./src/SpaceStation.Server/EntityFactory.cs ---

--- START: ./src/SpaceStation.Client/Program.cs ---
﻿using Arch.Core;
using LiteNetLib;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using SpaceStation.Core.Systems;
using SpaceStation.Content.Systems;
using SpaceStation.Content.Components;
using SpaceStation.Client.Graphics;
using SpaceStation.Client.Network;
using SpaceStation.Client.Resources;
using SpaceStation.Shared.Network;
using SpaceStation.Shared.Network.Packets;

namespace SpaceStation.Client;

/// <summary>
/// Main MonoGame game class for Space Station 13 client.
/// </summary>
public class SpaceStationGame : Game
{
    private readonly GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch = null!;

    // ECS
    private World _world = null!;
    private SystemManager _systems = null!;

    // Rendering
    private RenderSystem _renderSystem = null!;
    private Camera _camera;

    // Network
    private ClientNetworkManager _network = null!;
    private EntitySyncSystem _entitySync = null!;
    private bool _connected;
    private uint _lastReceivedTick;
    private int _playerCount;

    // Resources
    private ResourceManager _resourceManager = null!;

    // Local player
    private int _localPlayerEntityId;
    private uint _inputTick;
    private const float MinZoom = 0.5f;  // Max zoom out (27x15 tiles)
    private const float MaxZoom = 2f;    // Max zoom in

    // Debug
    private Texture2D? _pixel;
    private int _entityCount;
    private double _fps;

    public SpaceStationGame()
    {
        _graphics = new GraphicsDeviceManager(this)
        {
            PreferredBackBufferWidth = 1280,
            PreferredBackBufferHeight = 720,
            SynchronizeWithVerticalRetrace = true
        };

        Content.RootDirectory = "Content";
        IsMouseVisible = true;
        Window.Title = "Space Station 13 - C# Remake (Connecting...)";
        Window.AllowUserResizing = true;
    }

    protected override void Initialize()
    {
        Console.WriteLine("╔════════════════════════════════════════╗");
        Console.WriteLine("║     Space Station 13 - C# Remake       ║");
        Console.WriteLine("║          CLIENT v0.3.0-NET             ║");
        Console.WriteLine("╚════════════════════════════════════════╝");
        Console.WriteLine();

        // Initialize ECS World
        _world = World.Create();
        _systems = new SystemManager(_world);

        // Register game systems (for client-side prediction in the future)
        _systems.RegisterSystem<MovementSystem>();
        _systems.Initialize();

        // Initialize render system
        _renderSystem = new RenderSystem();

        // Initialize entity sync
        _entitySync = new EntitySyncSystem();

        // Initialize network
        _network = new ClientNetworkManager();
        _network.OnConnected += OnConnected;
        _network.OnDisconnected += OnDisconnected;
        _network.OnPlayerSpawned += OnPlayerSpawned;
        _network.Start();

        // Connect to localhost by default
        _network.Connect("localhost", NetworkConstants.DefaultPort);

        // Initialize camera
        _camera = new Camera(new Vector2(7 * 32, 7 * 32), 1f, 0f); // Center on map

        Console.WriteLine("[Client] Attempting to connect to server...");

        base.Initialize();
    }

    private void OnConnected(int clientId)
    {
        _connected = true;
        Window.Title = $"Space Station 13 - Client #{clientId}";
        Console.WriteLine($"[Client] Connected! Client ID: {clientId}");
    }

    private void OnDisconnected(string reason)
    {
        _connected = false;
        _localPlayerEntityId = 0;
        Window.Title = "Space Station 13 - Disconnected";
        Console.WriteLine($"[Client] Disconnected: {reason}");

        // Clear synced entities
        _entitySync.Clear(_world);
    }

    private void OnPlayerSpawned(int entityId)
    {
        _localPlayerEntityId = entityId;
        Console.WriteLine($"[Client] Local player entity: {entityId}");
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a 1x1 white pixel texture
        _pixel = new Texture2D(GraphicsDevice, 1, 1);
        _pixel.SetData(new[] { Color.White });

        // Initialize resource manager and load textures
        _resourceManager = new ResourceManager(GraphicsDevice);

        // Try to load textures from Resources/Textures
        var texturePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "..", "..", "Resources", "Textures");
        if (Directory.Exists(texturePath))
        {
            _resourceManager.LoadDirectory(texturePath);
        }
        else
        {
            // Try relative to working directory
            texturePath = "Resources/Textures";
            if (Directory.Exists(texturePath))
            {
                _resourceManager.LoadDirectory(texturePath);
            }
            else
            {
                Console.WriteLine($"[Client] WARNING: Texture directory not found!");
            }
        }

        // Set resources for entity sync
        _entitySync.DefaultTexture = _pixel;
        _entitySync.ResourceManager = _resourceManager;

        Console.WriteLine($"[Client] Content loaded - {_resourceManager.TotalStates} sprite states available");
    }

    protected override void Update(GameTime gameTime)
    {
        var deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds;
        _fps = 1.0 / gameTime.ElapsedGameTime.TotalSeconds;

        // Poll network
        _network.PollEvents();

        // Process network snapshots
        ProcessNetworkSnapshots();

        // Handle input
        HandleInput(deltaTime);

        // Update all ECS systems (for client-side prediction)
        // _systems.Update(deltaTime);

        // Update animations
        _renderSystem.UpdateAnimations(_world, deltaTime);

        // Track entity count
        _entityCount = _world.Size;

        base.Update(gameTime);
    }

    private void ProcessNetworkSnapshots()
    {
        // Process all available snapshots
        while (true)
        {
            var snapshot = _network.DequeueSnapshot();
            if (snapshot == null)
                break;

            _lastReceivedTick = snapshot.Header.Tick;
            _playerCount = snapshot.PlayerCount;

            // Apply snapshot to local world
            _entitySync.ApplySnapshot(_world, snapshot);
        }
    }

    private void HandleInput(float deltaTime)
    {
        var keyboard = Keyboard.GetState();

        // Exit on Escape
        if (keyboard.IsKeyDown(Keys.Escape))
        {
            Exit();
        }

        // Reconnect on R
        if (keyboard.IsKeyDown(Keys.R) && !_connected)
        {
            _network.Connect("localhost", NetworkConstants.DefaultPort);
        }

        // Player movement (WASD) - send to server
        if (_connected && _localPlayerEntityId > 0)
        {
            float moveX = 0, moveY = 0;

            if (keyboard.IsKeyDown(Keys.W) || keyboard.IsKeyDown(Keys.Up))
                moveY = -1;
            if (keyboard.IsKeyDown(Keys.S) || keyboard.IsKeyDown(Keys.Down))
                moveY = 1;
            if (keyboard.IsKeyDown(Keys.A) || keyboard.IsKeyDown(Keys.Left))
                moveX = -1;
            if (keyboard.IsKeyDown(Keys.D) || keyboard.IsKeyDown(Keys.Right))
                moveX = 1;

            // Send input to server
            var inputPacket = new PlayerInputPacket
            {
                MoveX = moveX,
                MoveY = moveY,
                InputTick = _inputTick++
            };
            var data = PacketSerializer.Serialize(inputPacket);
            _network.Send(data, DeliveryMethod.Sequenced);

            // Camera follows local player
            UpdateCameraFollow();
        }
        else
        {
            // Free camera when not controlling player (arrow keys)
            const float cameraSpeed = 300f;
            var cameraMove = Vector2.Zero;

            if (keyboard.IsKeyDown(Keys.Up))
                cameraMove.Y -= cameraSpeed * deltaTime;
            if (keyboard.IsKeyDown(Keys.Down))
                cameraMove.Y += cameraSpeed * deltaTime;
            if (keyboard.IsKeyDown(Keys.Left))
                cameraMove.X -= cameraSpeed * deltaTime;
            if (keyboard.IsKeyDown(Keys.Right))
                cameraMove.X += cameraSpeed * deltaTime;

            _camera.Position += cameraMove;
        }

        // Camera zoom with mouse scroll
        var mouse = Mouse.GetState();
        var scrollDelta = mouse.ScrollWheelValue / 1200f;
        _camera.Zoom = MathHelper.Clamp(_camera.Zoom + scrollDelta * 0.1f, MinZoom, MaxZoom);

        // Keyboard zoom
        if (keyboard.IsKeyDown(Keys.OemPlus) || keyboard.IsKeyDown(Keys.Add))
            _camera.Zoom = MathF.Min(MaxZoom, _camera.Zoom + deltaTime * 2);
        if (keyboard.IsKeyDown(Keys.OemMinus) || keyboard.IsKeyDown(Keys.Subtract))
            _camera.Zoom = MathF.Max(MinZoom, _camera.Zoom - deltaTime * 2);
    }

    private void UpdateCameraFollow()
    {
        // Find local player entity and follow it
        if (_localPlayerEntityId <= 0) return;

        var localEntity = _entitySync.GetEntityByNetId(_localPlayerEntityId);
        if (localEntity.HasValue && _world.IsAlive(localEntity.Value))
        {
            var transform = _world.Get<Transform>(localEntity.Value);
            var targetPos = new Vector2(transform.Position.X * 32, transform.Position.Y * 32);

            // Smooth camera follow (lerp)
            _camera.Position = Vector2.Lerp(_camera.Position, targetPos, 0.15f);
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(new Color(10, 10, 20)); // Dark space background

        // Render all entities
        _renderSystem.Draw(_world, _spriteBatch, _camera, GraphicsDevice.Viewport);

        // Draw debug info (commented for clean gameplay view)
        // DrawDebugInfo();

        base.Draw(gameTime);
    }

    private void DrawDebugInfo()
    {
        _spriteBatch.Begin();

        // Background panel
        var panelWidth = 220;
        var panelHeight = 100;
        _spriteBatch.Draw(_pixel, new Rectangle(10, 10, panelWidth, panelHeight), new Color(0, 0, 0, 200));

        // Connection status indicator
        var statusColor = _connected ? Color.LimeGreen : Color.Red;
        _spriteBatch.Draw(_pixel, new Rectangle(20, 20, 20, 20), statusColor);

        // FPS bar
        var fpsColor = _fps >= 55 ? Color.LimeGreen : (_fps >= 30 ? Color.Yellow : Color.Red);
        _spriteBatch.Draw(_pixel, new Rectangle(50, 20, (int)MathF.Min((float)_fps * 2, 160), 8), fpsColor);

        // Entity count bar
        _spriteBatch.Draw(_pixel, new Rectangle(50, 35, MathF.Min(_entityCount / 2, 160).ToInt(), 8), Color.Cyan);

        // Tick indicator
        var tickColor = Color.Magenta;
        _spriteBatch.Draw(_pixel, new Rectangle(50, 50, (int)(_lastReceivedTick % 100) * 2, 8), tickColor);

        // Ping bar
        var ping = _network.Ping;
        var pingColor = ping < 50 ? Color.LimeGreen : (ping < 100 ? Color.Yellow : Color.Red);
        _spriteBatch.Draw(_pixel, new Rectangle(50, 65, MathF.Min(ping / 2, 160).ToInt(), 8), pingColor);

        // Player count indicator
        _spriteBatch.Draw(_pixel, new Rectangle(50, 80, _playerCount * 20, 8), Color.Orange);

        _spriteBatch.End();
    }

    protected override void UnloadContent()
    {
        _network?.Dispose();
        _world?.Dispose();
        _systems?.Dispose();
        _resourceManager?.Dispose();
        _pixel?.Dispose();

        Console.WriteLine("[Client] Shutdown complete.");
    }
}

internal static class MathExtensions
{
    public static int ToInt(this float value) => (int)value;
}

/// <summary>
/// Client entry point.
/// </summary>
public static class Program
{
    public static void Main(string[] args)
    {
        using var game = new SpaceStationGame();
        game.Run();
    }
}

--- END: ./src/SpaceStation.Client/Program.cs ---

--- START: ./src/SpaceStation.Client/obj/Debug/net9.0/SpaceStation.Client.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Client/obj/Debug/net9.0/SpaceStation.Client.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Client/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Client/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Client/obj/Debug/net9.0/SpaceStation.Client.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Client")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Client")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Client")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Client/obj/Debug/net9.0/SpaceStation.Client.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Client/Graphics/SpriteComponents.cs ---
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace SpaceStation.Client.Graphics;

/// <summary>
/// Sprite component for rendering entities.
/// </summary>
public record struct Sprite(
    Texture2D? Texture = null,
    Rectangle SourceRect = default,
    Color Tint = default,
    float Scale = 1f,
    float LayerDepth = 0.5f
)
{
    public Sprite() : this(null, Rectangle.Empty, Color.White, 1f, 0.5f) { }
}

/// <summary>
/// Animated sprite component.
/// </summary>
public struct AnimatedSprite
{
    public Texture2D? Texture;
    public int FrameWidth;
    public int FrameHeight;
    public int CurrentFrame;
    public int TotalFrames;
    public float FrameTime;
    public float TimeAccumulator;
    public bool Loop;

    public Rectangle CurrentSourceRect => new(
        CurrentFrame * FrameWidth,
        0,
        FrameWidth,
        FrameHeight
    );
}

/// <summary>
/// Camera component for view transformation.
/// </summary>
public record struct Camera(
    Vector2 Position = default,
    float Zoom = 1f,
    float Rotation = 0f
)
{
    public readonly Matrix GetTransform(Viewport viewport)
    {
        return Matrix.CreateTranslation(new Vector3(-Position.X, -Position.Y, 0)) *
               Matrix.CreateRotationZ(Rotation) *
               Matrix.CreateScale(Zoom, Zoom, 1) *
               Matrix.CreateTranslation(new Vector3(viewport.Width / 2f, viewport.Height / 2f, 0));
    }
}

--- END: ./src/SpaceStation.Client/Graphics/SpriteComponents.cs ---

--- START: ./src/SpaceStation.Client/Graphics/RenderSystem.cs ---
using Arch.Core;
using Arch.Core.Extensions;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using SpaceStation.Content.Components;

namespace SpaceStation.Client.Graphics;

/// <summary>
/// System for rendering sprites to the screen.
/// </summary>
public sealed class RenderSystem
{
    private static readonly QueryDescription SpriteQuery = new QueryDescription()
        .WithAll<Transform, Sprite>();
        
    private static readonly QueryDescription AnimatedQuery = new QueryDescription()
        .WithAll<Transform, AnimatedSprite>();
    
    /// <summary>
    /// Draws all entities with sprite components.
    /// </summary>
    public void Draw(World world, SpriteBatch spriteBatch, Camera camera, Viewport viewport)
    {
        spriteBatch.Begin(
            SpriteSortMode.BackToFront,
            BlendState.AlphaBlend,
            SamplerState.PointClamp,
            null,
            null,
            null,
            camera.GetTransform(viewport)
        );
        
        // Draw static sprites
        world.Query(in SpriteQuery, (ref Transform transform, ref Sprite sprite) =>
        {
            if (sprite.Texture == null)
                return;
                
            var position = new Vector2(transform.Position.X * 32, transform.Position.Y * 32);
            var sourceRect = sprite.SourceRect == Rectangle.Empty 
                ? null as Rectangle?
                : sprite.SourceRect;
                
            spriteBatch.Draw(
                sprite.Texture,
                position,
                sourceRect,
                sprite.Tint,
                transform.Rotation,
                Vector2.Zero,
                sprite.Scale,
                SpriteEffects.None,
                sprite.LayerDepth
            );
        });
        
        // Draw animated sprites
        world.Query(in AnimatedQuery, (ref Transform transform, ref AnimatedSprite anim) =>
        {
            if (anim.Texture == null)
                return;
                
            var position = new Vector2(transform.Position.X * 32, transform.Position.Y * 32);
            
            spriteBatch.Draw(
                anim.Texture,
                position,
                anim.CurrentSourceRect,
                Color.White,
                transform.Rotation,
                Vector2.Zero,
                1f,
                SpriteEffects.None,
                0.5f
            );
        });
        
        spriteBatch.End();
    }
    
    /// <summary>
    /// Updates animated sprites.
    /// </summary>
    public void UpdateAnimations(World world, float deltaTime)
    {
        world.Query(in AnimatedQuery, (ref AnimatedSprite anim) =>
        {
            anim.TimeAccumulator += deltaTime;
            
            if (anim.TimeAccumulator >= anim.FrameTime)
            {
                anim.TimeAccumulator -= anim.FrameTime;
                anim.CurrentFrame++;
                
                if (anim.CurrentFrame >= anim.TotalFrames)
                {
                    anim.CurrentFrame = anim.Loop ? 0 : anim.TotalFrames - 1;
                }
            }
        });
    }
}

--- END: ./src/SpaceStation.Client/Graphics/RenderSystem.cs ---

--- START: ./src/SpaceStation.Client/Network/ClientNetworkManager.cs ---
using LiteNetLib;
using LiteNetLib.Utils;
using SpaceStation.Shared.Network;
using SpaceStation.Shared.Network.Packets;

namespace SpaceStation.Client.Network;

/// <summary>
/// Client-side network manager for connecting to server and receiving game state.
/// </summary>
public sealed class ClientNetworkManager : INetEventListener, IDisposable
{
    private readonly NetManager _netManager;
    private NetPeer? _serverPeer;
    private int _clientId;
    
    private readonly Queue<WorldSnapshotPacket> _snapshotQueue = new();
    private readonly object _queueLock = new();
    
    public bool IsConnected => _serverPeer?.ConnectionState == ConnectionState.Connected;
    public int ClientId => _clientId;
    public int Ping => _serverPeer?.Ping ?? 0;
    
    /// <summary>Network entity ID of local player (0 if not assigned).</summary>
    public int PlayerEntityId { get; private set; }
    
    /// <summary>Event when connected to server.</summary>
    public event Action<int>? OnConnected;
    
    /// <summary>Event when disconnected from server.</summary>
    public event Action<string>? OnDisconnected;
    
    /// <summary>Event when world snapshot received.</summary>
    public event Action<WorldSnapshotPacket>? OnSnapshotReceived;
    
    /// <summary>Event when player entity is assigned.</summary>
    public event Action<int>? OnPlayerSpawned;
    
    public ClientNetworkManager()
    {
        _netManager = new NetManager(this)
        {
            AutoRecycle = true,
            DisconnectTimeout = NetworkConstants.DisconnectTimeout,
            PingInterval = NetworkConstants.PingInterval,
            UnconnectedMessagesEnabled = false
        };
    }
    
    /// <summary>
    /// Starts the client network manager.
    /// </summary>
    public void Start()
    {
        _netManager.Start();
        Console.WriteLine($"[Network] Client started");
    }
    
    /// <summary>
    /// Connects to a server.
    /// </summary>
    public void Connect(string host = "localhost", int port = NetworkConstants.DefaultPort)
    {
        Console.WriteLine($"[Network] Connecting to {host}:{port}...");
        
        var writer = new NetDataWriter();
        writer.Put(NetworkConstants.ConnectionKey);
        
        _netManager.Connect(host, port, writer);
    }
    
    /// <summary>
    /// Disconnects from the server.
    /// </summary>
    public void Disconnect()
    {
        _serverPeer?.Disconnect();
    }
    
    /// <summary>
    /// Stops the client.
    /// </summary>
    public void Stop()
    {
        _netManager.Stop();
        _serverPeer = null;
        Console.WriteLine("[Network] Client stopped");
    }
    
    /// <summary>
    /// Polls network events. Should be called every frame.
    /// </summary>
    public void PollEvents()
    {
        _netManager.PollEvents();
    }
    
    /// <summary>
    /// Gets the next snapshot from the queue.
    /// </summary>
    public WorldSnapshotPacket? DequeueSnapshot()
    {
        lock (_queueLock)
        {
            return _snapshotQueue.Count > 0 ? _snapshotQueue.Dequeue() : null;
        }
    }
    
    /// <summary>
    /// Sends data to the server.
    /// </summary>
    public void Send(byte[] data, DeliveryMethod deliveryMethod = DeliveryMethod.ReliableOrdered)
    {
        _serverPeer?.Send(data, deliveryMethod);
    }
    
    // INetEventListener implementation
    
    public void OnConnectionRequest(ConnectionRequest request)
    {
        // Client doesn't accept incoming connections
        request.Reject();
    }
    
    public void OnPeerConnected(NetPeer peer)
    {
        _serverPeer = peer;
        Console.WriteLine($"[Network] Connected to server at {peer.Address}:{peer.Port}");
    }
    
    public void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
    {
        _serverPeer = null;
        Console.WriteLine($"[Network] Disconnected from server: {disconnectInfo.Reason}");
        OnDisconnected?.Invoke(disconnectInfo.Reason.ToString());
    }
    
    public void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
    {
        var data = new byte[reader.AvailableBytes];
        reader.GetBytes(data, data.Length);
        
        ProcessPacket(data);
    }
    
    private void ProcessPacket(byte[] data)
    {
        try
        {
            // Try to deserialize as ConnectionAccepted first
            var connectionAccepted = PacketSerializer.DeserializeConnectionAccepted(data);
            if (connectionAccepted != null && connectionAccepted.Header.Type == PacketType.ConnectionAccepted)
            {
                _clientId = connectionAccepted.ClientId;
                Console.WriteLine($"[Network] Connection accepted! Client ID: {_clientId}");
                OnConnected?.Invoke(_clientId);
                return;
            }
            
            // Try PlayerSpawned packet
            var playerSpawned = PacketSerializer.Deserialize<PlayerSpawnedPacket>(data);
            if (playerSpawned != null && playerSpawned.Header.Type == PacketType.PlayerSpawned)
            {
                PlayerEntityId = playerSpawned.EntityId;
                Console.WriteLine($"[Network] Player entity assigned: {PlayerEntityId}");
                OnPlayerSpawned?.Invoke(PlayerEntityId);
                return;
            }
            
            // Try to deserialize as WorldSnapshot
            var snapshot = PacketSerializer.DeserializeSnapshot(data);
            if (snapshot != null && snapshot.Header.Type == PacketType.WorldSnapshot)
            {
                lock (_queueLock)
                {
                    // Keep only latest few snapshots to prevent lag buildup
                    while (_snapshotQueue.Count > 3)
                    {
                        _snapshotQueue.Dequeue();
                    }
                    _snapshotQueue.Enqueue(snapshot);
                }
                OnSnapshotReceived?.Invoke(snapshot);
                return;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Network] Error processing packet: {ex.Message}");
        }
    }
    
    public void OnNetworkError(System.Net.IPEndPoint endPoint, System.Net.Sockets.SocketError socketError)
    {
        Console.WriteLine($"[Network] Error: {socketError}");
    }
    
    public void OnNetworkReceiveUnconnected(System.Net.IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
    {
        // Not used
    }
    
    public void OnNetworkLatencyUpdate(NetPeer peer, int latency)
    {
        // Could be used for ping display
    }
    
    public void Dispose()
    {
        Stop();
    }
}

--- END: ./src/SpaceStation.Client/Network/ClientNetworkManager.cs ---

--- START: ./src/SpaceStation.Client/Network/EntitySyncSystem.cs ---
using Arch.Core;
using Arch.Core.Extensions;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using SpaceStation.Content.Components;
using SpaceStation.Client.Graphics;
using SpaceStation.Client.Resources;
using SpaceStation.Shared.Network.Packets;
using SpaceStation.Shared.Enums;

namespace SpaceStation.Client.Network;

/// <summary>
/// Synchronizes local ECS entities with server world state.
/// </summary>
public sealed class EntitySyncSystem
{
    private readonly Dictionary<int, Entity> _networkToLocal = new();
    private readonly Dictionary<Entity, int> _localToNetwork = new();

    /// <summary>
    /// Fallback texture for entities without valid sprites.
    /// </summary>
    public Texture2D? DefaultTexture { get; set; }

    /// <summary>
    /// Resource manager for loading sprites.
    /// </summary>
    public ResourceManager? ResourceManager { get; set; }

    /// <summary>
    /// Gets local entity by network ID.
    /// </summary>
    public Entity? GetEntityByNetId(int netId)
    {
        return _networkToLocal.TryGetValue(netId, out var entity) ? entity : null;
    }

    /// <summary>
    /// Applies a world snapshot to the local ECS world.
    /// </summary>
    public void ApplySnapshot(World world, WorldSnapshotPacket snapshot)
    {
        var receivedIds = new HashSet<int>();

        foreach (var netEntity in snapshot.Entities)
        {
            receivedIds.Add(netEntity.EntityId);

            if (_networkToLocal.TryGetValue(netEntity.EntityId, out var localEntity))
            {
                // Update existing entity
                UpdateEntity(world, localEntity, netEntity);
            }
            else
            {
                // Create new entity
                localEntity = CreateEntity(world, netEntity);
                _networkToLocal[netEntity.EntityId] = localEntity;
                _localToNetwork[localEntity] = netEntity.EntityId;
            }
        }

        // Remove entities that no longer exist on server
        var toRemove = _networkToLocal
            .Where(kvp => !receivedIds.Contains(kvp.Key))
            .ToList();

        foreach (var kvp in toRemove)
        {
            if (world.IsAlive(kvp.Value))
            {
                world.Destroy(kvp.Value);
            }
            _networkToLocal.Remove(kvp.Key);
            _localToNetwork.Remove(kvp.Value);
        }
    }

    private Entity CreateEntity(World world, NetworkEntity netEntity)
    {
        // Create base entity with transform
        var transform = new Transform(
            new System.Numerics.Vector2(netEntity.Transform.X, netEntity.Transform.Y),
            netEntity.Transform.Rotation,
            netEntity.Transform.ZLevel
        );

        // Get sprite from network data or fallback
        var sprite = CreateSprite(netEntity);

        Entity entity;

        if (netEntity.Physics.HasValue)
        {
            var physics = netEntity.Physics.Value;
            var physicsComp = new Physics(
                new System.Numerics.Vector2(physics.VelocityX, physics.VelocityY),
                physics.MoveSpeed,
                1f,
                0.5f,
                physics.Dense,
                physics.Anchored
            );

            if (netEntity.Health.HasValue)
            {
                var health = netEntity.Health.Value;
                entity = world.Create(
                    transform,
                    physicsComp,
                    sprite,
                    new Health(health.MaxHealth, health.CurrentHealth, (MobState)health.State),
                    new Damageable()
                );
            }
            else
            {
                entity = world.Create(transform, physicsComp, sprite);
            }
        }
        else
        {
            entity = world.Create(transform, sprite);
        }

        return entity;
    }

    private Sprite CreateSprite(NetworkEntity netEntity)
    {
        Texture2D? texture = DefaultTexture;
        Rectangle sourceRect = Rectangle.Empty;
        Color tint = Color.White;
        float scale = 1f;

        // Try to load from ResourceManager if sprite data is present
        if (netEntity.Sprite.HasValue && ResourceManager != null)
        {
            var netSprite = netEntity.Sprite.Value;

            // Try to get sprite from resource manager
            var spriteData = ResourceManager.GetSprite(netSprite.TextureId);

            if (spriteData.IsValid)
            {
                texture = spriteData.Texture;
                sourceRect = spriteData.SourceRect;
            }
            else
            {
                // Missing texture - use magenta fallback
                tint = Color.Magenta;
            }

            // Use network tint if provided
            if (netSprite.TintA > 0)
            {
                tint = new Color(netSprite.TintR, netSprite.TintG, netSprite.TintB, netSprite.TintA);
            }

            scale = netSprite.Scale > 0 ? netSprite.Scale : 1f;
        }
        else
        {
            // No sprite data from network - use procedural color
            tint = DetermineColor(netEntity);
        }

        return new Sprite(texture, sourceRect, tint, scale, 0.5f);
    }


    private void UpdateEntity(World world, Entity entity, NetworkEntity netEntity)
    {
        if (!world.IsAlive(entity))
            return;

        // Update transform
        if (world.Has<Transform>(entity))
        {
            ref var transform = ref world.Get<Transform>(entity);
            transform = new Transform(
                new System.Numerics.Vector2(netEntity.Transform.X, netEntity.Transform.Y),
                netEntity.Transform.Rotation,
                netEntity.Transform.ZLevel
            );
        }

        // Update physics
        if (netEntity.Physics.HasValue && world.Has<Physics>(entity))
        {
            ref var physics = ref world.Get<Physics>(entity);
            var net = netEntity.Physics.Value;
            physics = new Physics(
                new System.Numerics.Vector2(net.VelocityX, net.VelocityY),
                net.MoveSpeed,
                physics.Mass,
                physics.Friction,
                net.Dense,
                net.Anchored
            );
        }

        // Update health
        if (netEntity.Health.HasValue && world.Has<Health>(entity))
        {
            ref var health = ref world.Get<Health>(entity);
            var net = netEntity.Health.Value;
            health = new Health(net.MaxHealth, net.CurrentHealth, (MobState)net.State);
        }
    }

    private Color DetermineColor(NetworkEntity netEntity)
    {
        // Color based on entity type
        if (netEntity.Health.HasValue)
        {
            // Mobs - yellow/orange
            return Color.Yellow;
        }
        else if (netEntity.Physics.HasValue)
        {
            if (netEntity.Physics.Value.Anchored)
            {
                if (netEntity.Physics.Value.Dense)
                {
                    // Wall - dark gray
                    return new Color(60, 60, 70);
                }
                else
                {
                    // Floor - varied colors
                    var hue = ((int)(netEntity.Transform.X + netEntity.Transform.Y) * 37) % 360;
                    return HsvToRgb(hue, 0.4f, 0.6f);
                }
            }
        }

        // Default - white
        return Color.White;
    }

    private static Color HsvToRgb(float h, float s, float v)
    {
        float c = v * s;
        float x = c * (1 - MathF.Abs((h / 60f) % 2 - 1));
        float m = v - c;

        float r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        return new Color(r + m, g + m, b + m);
    }

    /// <summary>
    /// Clears all tracked entities.
    /// </summary>
    public void Clear(World world)
    {
        foreach (var entity in _networkToLocal.Values)
        {
            if (world.IsAlive(entity))
            {
                world.Destroy(entity);
            }
        }
        _networkToLocal.Clear();
        _localToNetwork.Clear();
    }

    /// <summary>
    /// Gets statistics about synced entities.
    /// </summary>
    public int SyncedEntityCount => _networkToLocal.Count;
}

--- END: ./src/SpaceStation.Client/Network/EntitySyncSystem.cs ---

--- START: ./src/SpaceStation.Client/Resources/DmiAtlas.cs ---
using System.Text.Json.Serialization;

namespace SpaceStation.Client.Resources;

/// <summary>
/// Represents a parsed DMI JSON atlas file.
/// </summary>
public class DmiAtlas
{
    [JsonPropertyName("meta")]
    public DmiMeta Meta { get; set; } = new();
    
    [JsonPropertyName("states")]
    public Dictionary<string, DmiState> States { get; set; } = new();
}

/// <summary>
/// Metadata from DMI atlas.
/// </summary>
public class DmiMeta
{
    [JsonPropertyName("source")]
    public string? Source { get; set; }
    
    [JsonPropertyName("image")]
    public string? Image { get; set; }
    
    [JsonPropertyName("size")]
    public DmiSize Size { get; set; } = new();
}

/// <summary>
/// Default sprite size.
/// </summary>
public class DmiSize
{
    [JsonPropertyName("w")]
    public int Width { get; set; } = 32;
    
    [JsonPropertyName("h")]
    public int Height { get; set; } = 32;
}

/// <summary>
/// A single icon state within the atlas.
/// </summary>
public class DmiState
{
    [JsonPropertyName("loop")]
    public bool Loop { get; set; } = true;
    
    [JsonPropertyName("directions")]
    public Dictionary<string, List<DmiFrame>>? Directions { get; set; }
}

/// <summary>
/// A single frame of animation.
/// </summary>
public class DmiFrame
{
    [JsonPropertyName("x")]
    public int X { get; set; }
    
    [JsonPropertyName("y")]
    public int Y { get; set; }
    
    [JsonPropertyName("w")]
    public int W { get; set; } = 32;
    
    [JsonPropertyName("h")]
    public int H { get; set; } = 32;
    
    [JsonPropertyName("delay_ms")]
    public float DelayMs { get; set; } = 100f;
}

--- END: ./src/SpaceStation.Client/Resources/DmiAtlas.cs ---

--- START: ./src/SpaceStation.Client/Resources/SpriteData.cs ---
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace SpaceStation.Client.Resources;

/// <summary>
/// Sprite data returned by ResourceManager.
/// </summary>
public readonly record struct SpriteData(
    Texture2D Texture,
    Rectangle SourceRect,
    Vector2 Origin
)
{
    public static readonly SpriteData Empty = default;

    public bool IsValid => Texture != null;
}

/// <summary>
/// Animation data for animated sprites.
/// </summary>
public class AnimationData
{
    public Texture2D Texture { get; init; } = null!;
    public AnimationFrame[] Frames { get; init; } = Array.Empty<AnimationFrame>();
    public bool Loop { get; init; } = true;
    public float TotalDuration { get; init; }

    public static readonly AnimationData Empty = new();

    public bool IsValid => Texture != null && Frames.Length > 0;
}

/// <summary>
/// A single frame of animation with timing.
/// </summary>
public readonly record struct AnimationFrame(
    Rectangle SourceRect,
    float Duration,
    float StartTime
);

/// <summary>
/// Direction for directional sprites.
/// </summary>
public enum SpriteDirection
{
    South = 0,
    North = 1,
    East = 2,
    West = 3
}

/// <summary>
/// Extension methods for SpriteDirection.
/// </summary>
public static class SpriteDirectionExtensions
{
    public static string ToJsonKey(this SpriteDirection dir) => dir switch
    {
        SpriteDirection.South => "south",
        SpriteDirection.North => "north",
        SpriteDirection.East => "east",
        SpriteDirection.West => "west",
        _ => "south"
    };

    public static SpriteDirection FromAngle(float radians)
    {
        var degrees = MathHelper.ToDegrees(radians);
        degrees = (degrees % 360 + 360) % 360;

        return degrees switch
        {
            >= 315 or < 45 => SpriteDirection.East,
            >= 45 and < 135 => SpriteDirection.South,
            >= 135 and < 225 => SpriteDirection.West,
            _ => SpriteDirection.North
        };
    }
}

--- END: ./src/SpaceStation.Client/Resources/SpriteData.cs ---

--- START: ./src/SpaceStation.Client/Resources/ResourceManager.cs ---
using System.Text.Json;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace SpaceStation.Client.Resources;

/// <summary>
/// Manages game resources including textures and DMI atlases.
/// Loads and caches textures, provides sprite lookup by state name.
/// </summary>
public sealed class ResourceManager : IDisposable
{
    private readonly GraphicsDevice _graphicsDevice;
    private readonly Dictionary<string, Texture2D> _textures = new();
    private readonly Dictionary<string, DmiAtlas> _atlases = new();
    private readonly Dictionary<string, string> _stateToAtlas = new(); // state -> atlas id lookup
    
    private bool _isDisposed;
    
    /// <summary>Number of loaded atlases.</summary>
    public int AtlasCount => _atlases.Count;
    
    /// <summary>Number of loaded textures.</summary>
    public int TextureCount => _textures.Count;
    
    /// <summary>Total number of sprite states available.</summary>
    public int TotalStates => _stateToAtlas.Count;
    
    public ResourceManager(GraphicsDevice graphicsDevice)
    {
        _graphicsDevice = graphicsDevice ?? throw new ArgumentNullException(nameof(graphicsDevice));
    }
    
    /// <summary>
    /// Loads all DMI JSON atlases from a directory recursively.
    /// </summary>
    /// <param name="rootPath">Root directory to scan.</param>
    public void LoadDirectory(string rootPath)
    {
        if (!Directory.Exists(rootPath))
        {
            Console.WriteLine($"[ResourceManager] Directory not found: {rootPath}");
            return;
        }
        
        var jsonFiles = Directory.GetFiles(rootPath, "*.json", SearchOption.AllDirectories);
        var loaded = 0;
        var errors = 0;
        
        foreach (var jsonFile in jsonFiles)
        {
            try
            {
                LoadAtlas(jsonFile);
                loaded++;
            }
            catch (Exception ex)
            {
                errors++;
                Console.WriteLine($"[ResourceManager] Failed to load {jsonFile}: {ex.Message}");
            }
        }
        
        Console.WriteLine($"[ResourceManager] Loaded {loaded} atlases, {errors} errors, {TotalStates} total states");
    }
    
    /// <summary>
    /// Loads a single DMI JSON atlas file.
    /// </summary>
    public void LoadAtlas(string jsonPath)
    {
        var jsonContent = File.ReadAllText(jsonPath);
        var atlas = JsonSerializer.Deserialize<DmiAtlas>(jsonContent);
        
        if (atlas == null || atlas.Meta.Image == null)
        {
            throw new InvalidDataException($"Invalid atlas format: {jsonPath}");
        }
        
        // Generate atlas ID from relative path
        var atlasId = Path.GetFileNameWithoutExtension(jsonPath);
        var directory = Path.GetDirectoryName(jsonPath) ?? "";
        
        // Load associated texture
        var texturePath = Path.Combine(directory, atlas.Meta.Image);
        if (!File.Exists(texturePath))
        {
            throw new FileNotFoundException($"Texture not found: {texturePath}");
        }
        
        // Load texture using MonoGame
        using var stream = File.OpenRead(texturePath);
        var texture = Texture2D.FromStream(_graphicsDevice, stream);
        
        // Store with unique ID
        var uniqueId = GetUniqueAtlasId(atlasId, jsonPath);
        _atlases[uniqueId] = atlas;
        _textures[uniqueId] = texture;
        
        // Index all states for quick lookup
        foreach (var stateName in atlas.States.Keys)
        {
            // Use first occurrence if duplicate
            if (!_stateToAtlas.ContainsKey(stateName))
            {
                _stateToAtlas[stateName] = uniqueId;
            }
        }
    }
    
    private static string GetUniqueAtlasId(string baseName, string fullPath)
    {
        // Create ID based on directory structure
        var parts = fullPath.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        var relevantParts = parts
            .SkipWhile(p => p != "Textures")
            .Skip(1) // Skip "Textures" itself
            .Take(parts.Length)
            .Select(p => Path.GetFileNameWithoutExtension(p));
        
        return string.Join("/", relevantParts);
    }
    
    /// <summary>
    /// Gets a sprite by state name, searching all loaded atlases.
    /// </summary>
    /// <param name="stateName">The icon state name (e.g., "floor_steel").</param>
    /// <param name="direction">Direction for directional sprites.</param>
    /// <returns>SpriteData with texture and source rectangle.</returns>
    public SpriteData GetSprite(string stateName, SpriteDirection direction = SpriteDirection.South)
    {
        if (!_stateToAtlas.TryGetValue(stateName, out var atlasId))
        {
            return SpriteData.Empty;
        }
        
        return GetSprite(atlasId, stateName, direction);
    }
    
    /// <summary>
    /// Gets a sprite from a specific atlas.
    /// </summary>
    /// <param name="atlasId">Atlas identifier.</param>
    /// <param name="stateName">Icon state name.</param>
    /// <param name="direction">Direction for directional sprites.</param>
    public SpriteData GetSprite(string atlasId, string stateName, SpriteDirection direction = SpriteDirection.South)
    {
        if (!_atlases.TryGetValue(atlasId, out var atlas) ||
            !_textures.TryGetValue(atlasId, out var texture))
        {
            return SpriteData.Empty;
        }
        
        if (!atlas.States.TryGetValue(stateName, out var state))
        {
            return SpriteData.Empty;
        }
        
        // Get first frame of the requested direction
        var dirKey = direction.ToJsonKey();
        List<DmiFrame>? frames = null;
        
        if (state.Directions != null)
        {
            if (!state.Directions.TryGetValue(dirKey, out frames) || frames.Count == 0)
            {
                // Fallback to south or first available
                if (!state.Directions.TryGetValue("south", out frames) || frames.Count == 0)
                {
                    frames = state.Directions.Values.FirstOrDefault();
                }
            }
        }
        
        if (frames == null || frames.Count == 0)
        {
            // Use default size from meta
            return new SpriteData(
                texture,
                new Rectangle(0, 0, atlas.Meta.Size.Width, atlas.Meta.Size.Height),
                new Vector2(atlas.Meta.Size.Width / 2f, atlas.Meta.Size.Height / 2f)
            );
        }
        
        var frame = frames[0];
        return new SpriteData(
            texture,
            new Rectangle(frame.X, frame.Y, frame.W, frame.H),
            new Vector2(frame.W / 2f, frame.H / 2f)
        );
    }
    
    /// <summary>
    /// Gets animation data for an animated sprite.
    /// </summary>
    public AnimationData GetAnimation(string stateName, SpriteDirection direction = SpriteDirection.South)
    {
        if (!_stateToAtlas.TryGetValue(stateName, out var atlasId))
        {
            return AnimationData.Empty;
        }
        
        return GetAnimation(atlasId, stateName, direction);
    }
    
    /// <summary>
    /// Gets animation data from a specific atlas.
    /// </summary>
    public AnimationData GetAnimation(string atlasId, string stateName, SpriteDirection direction = SpriteDirection.South)
    {
        if (!_atlases.TryGetValue(atlasId, out var atlas) ||
            !_textures.TryGetValue(atlasId, out var texture))
        {
            return AnimationData.Empty;
        }
        
        if (!atlas.States.TryGetValue(stateName, out var state) || state.Directions == null)
        {
            return AnimationData.Empty;
        }
        
        var dirKey = direction.ToJsonKey();
        if (!state.Directions.TryGetValue(dirKey, out var dmiFrames) || dmiFrames.Count == 0)
        {
            if (!state.Directions.TryGetValue("south", out dmiFrames) || dmiFrames.Count == 0)
            {
                dmiFrames = state.Directions.Values.FirstOrDefault();
            }
        }
        
        if (dmiFrames == null || dmiFrames.Count == 0)
        {
            return AnimationData.Empty;
        }
        
        // Convert to AnimationFrame array
        var frames = new AnimationFrame[dmiFrames.Count];
        float currentTime = 0f;
        
        for (int i = 0; i < dmiFrames.Count; i++)
        {
            var dmi = dmiFrames[i];
            var duration = dmi.DelayMs / 1000f; // Convert ms to seconds
            
            frames[i] = new AnimationFrame(
                new Rectangle(dmi.X, dmi.Y, dmi.W, dmi.H),
                duration,
                currentTime
            );
            
            currentTime += duration;
        }
        
        return new AnimationData
        {
            Texture = texture,
            Frames = frames,
            Loop = state.Loop,
            TotalDuration = currentTime
        };
    }
    
    /// <summary>
    /// Checks if a state exists.
    /// </summary>
    public bool HasState(string stateName) => _stateToAtlas.ContainsKey(stateName);
    
    /// <summary>
    /// Gets the atlas ID for a state.
    /// </summary>
    public string? GetAtlasForState(string stateName) => 
        _stateToAtlas.TryGetValue(stateName, out var id) ? id : null;
    
    /// <summary>
    /// Lists all available states (for debugging).
    /// </summary>
    public IEnumerable<string> GetAllStates() => _stateToAtlas.Keys;
    
    /// <summary>
    /// Searches for states containing a query string.
    /// </summary>
    public IEnumerable<string> SearchStates(string query)
    {
        var lowerQuery = query.ToLowerInvariant();
        return _stateToAtlas.Keys.Where(s => s.ToLowerInvariant().Contains(lowerQuery));
    }
    
    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;
        
        foreach (var texture in _textures.Values)
        {
            texture.Dispose();
        }
        
        _textures.Clear();
        _atlases.Clear();
        _stateToAtlas.Clear();
    }
}

--- END: ./src/SpaceStation.Client/Resources/ResourceManager.cs ---

--- START: ./src/SpaceStation.Tests/obj/Debug/net9.0/SpaceStation.Tests.GlobalUsings.g.cs ---
// <auto-generated/>
global using global::NUnit.Framework;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

--- END: ./src/SpaceStation.Tests/obj/Debug/net9.0/SpaceStation.Tests.GlobalUsings.g.cs ---

--- START: ./src/SpaceStation.Tests/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

--- END: ./src/SpaceStation.Tests/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs ---

--- START: ./src/SpaceStation.Tests/obj/Debug/net9.0/SpaceStation.Tests.AssemblyInfo.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("SpaceStation.Tests")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5a4827d1b42d7991453e939b61b6f48bc0005ac6")]
[assembly: System.Reflection.AssemblyProductAttribute("SpaceStation.Tests")]
[assembly: System.Reflection.AssemblyTitleAttribute("SpaceStation.Tests")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


--- END: ./src/SpaceStation.Tests/obj/Debug/net9.0/SpaceStation.Tests.AssemblyInfo.cs ---

--- START: ./src/SpaceStation.Tests/MovementTests.cs ---
using System.Numerics;
using Arch.Core;
using Arch.Core.Extensions;
using SpaceStation.Content.Components;
using SpaceStation.Content.Systems;

namespace SpaceStation.Tests;

/// <summary>
/// Tests for grid-based movement system.
/// </summary>
[TestFixture]
public class MovementTests
{
    private World _world = null!;
    private MovementSystem _movementSystem = null!;

    [SetUp]
    public void Setup()
    {
        _world = World.Create();
        _movementSystem = new MovementSystem();
    }

    [TearDown]
    public void Teardown()
    {
        _world.Dispose();
    }

    /// <summary>
    /// Test that entity snaps to exact tile coordinates after movement.
    /// Position should be EXACTLY (6, 5), not (6.2, 5) or (5.8, 5).
    /// </summary>
    [Test]
    public void Test_Movement_Snapping()
    {
        // Arrange: Entity at (5, 5)
        var entity = _world.Create(
            new Transform(new Vector2(5, 5), 0f, 0),
            new Physics(Vector2.Zero, 4f, 70f, 0f, true, false),
            new InputState(MoveX: 1, MoveY: 0) // Right
        );

        // Act: First update starts movement
        _movementSystem.Update(0.05f, _world);

        // Clear input so we only do one move
        _world.Set(entity, new InputState(0, 0));

        // Continue until move completes
        for (int i = 0; i < 30; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Assert: Position should be EXACTLY (6, 5)
        var transform = _world.Get<Transform>(entity);
        Assert.That(transform.Position.X, Is.EqualTo(6f).Within(0.001f), "X position should be exactly 6");
        Assert.That(transform.Position.Y, Is.EqualTo(5f).Within(0.001f), "Y position should be exactly 5");
    }

    /// <summary>
    /// Test that entity cannot move through a wall.
    /// </summary>
    [Test]
    public void Test_Wall_Collision()
    {
        // Arrange: Set up collision checker to block (6, 5)
        _movementSystem.IsPassable = (x, y) => !(x == 6 && y == 5);

        // Entity at (5, 5) trying to move right into wall
        var entity = _world.Create(
            new Transform(new Vector2(5, 5), 0f, 0),
            new Physics(Vector2.Zero, 4f, 70f, 0f, true, false),
            new InputState(MoveX: 1, MoveY: 0) // Right
        );

        // Act: Simulate movement
        _movementSystem.Update(0.05f, _world);
        _world.Set(entity, new InputState(0, 0));

        for (int i = 0; i < 20; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Assert: Position should remain at (5, 5)
        var transform = _world.Get<Transform>(entity);
        Assert.That(transform.Position.X, Is.EqualTo(5f).Within(0.001f), "X should stay at 5 (blocked)");
        Assert.That(transform.Position.Y, Is.EqualTo(5f).Within(0.001f), "Y should stay at 5");
    }

    /// <summary>
    /// Test that diagonal input is resolved to cardinal direction.
    /// </summary>
    [Test]
    public void Test_Diagonal_Prevention()
    {
        // Arrange: Entity with diagonal input (right + down)
        var entity = _world.Create(
            new Transform(new Vector2(5, 5), 0f, 0),
            new Physics(Vector2.Zero, 4f, 70f, 0f, true, false),
            new InputState(MoveX: 1, MoveY: 1) // Diagonal
        );

        // Act: Single update starts movement
        _movementSystem.Update(0.05f, _world);

        // Clear input
        _world.Set(entity, new InputState(0, 0));

        // Complete the move
        for (int i = 0; i < 30; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Assert: Should only move in one cardinal direction (horizontal preferred)
        var transform = _world.Get<Transform>(entity);

        // Should have moved exactly 1 tile right
        Assert.That(transform.Position.X, Is.EqualTo(6f).Within(0.001f),
            $"X should be 6 (moved right). Actual: {transform.Position.X}");
        Assert.That(transform.Position.Y, Is.EqualTo(5f).Within(0.001f),
            $"Y should stay at 5. Actual: {transform.Position.Y}");
    }

    /// <summary>
    /// Test that anchored entities don't move.
    /// </summary>
    [Test]
    public void Test_Anchored_Entity_NoMove()
    {
        // Arrange: Anchored entity
        var entity = _world.Create(
            new Transform(new Vector2(5, 5), 0f, 0),
            new Physics(Vector2.Zero, 4f, 70f, 0f, true, true), // Anchored = true
            new InputState(MoveX: 1, MoveY: 0)
        );

        // Act
        for (int i = 0; i < 20; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Assert: Position unchanged
        var transform = _world.Get<Transform>(entity);
        Assert.That(transform.Position.X, Is.EqualTo(5f).Within(0.001f));
        Assert.That(transform.Position.Y, Is.EqualTo(5f).Within(0.001f));
    }

    /// <summary>
    /// Test multiple tile movements in sequence with persistent input.
    /// </summary>
    [Test]
    public void Test_Multiple_Tile_Movement()
    {
        // Arrange: Entity with continuous right input
        var entity = _world.Create(
            new Transform(new Vector2(5, 5), 0f, 0),
            new Physics(Vector2.Zero, 4f, 70f, 0f, true, false),
            new InputState(MoveX: 1, MoveY: 0)
        );

        // Act: Simulate long enough for multiple moves
        for (int i = 0; i < 80; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Clear input and wait for final move to complete
        _world.Set(entity, new InputState(0, 0));
        for (int i = 0; i < 30; i++)
        {
            _movementSystem.Update(0.05f, _world);
        }

        // Assert: Should have moved multiple tiles to the right
        var transform = _world.Get<Transform>(entity);
        Assert.That(transform.Position.X, Is.GreaterThan(6f), "Should have moved multiple tiles right");

        // Final position should be snapped (integer X)
        float fracPart = transform.Position.X - MathF.Floor(transform.Position.X);
        Assert.That(fracPart, Is.EqualTo(0f).Within(0.01f),
            $"X should be integer (snapped). Actual: {transform.Position.X}");
        Assert.That(transform.Position.Y, Is.EqualTo(5f).Within(0.001f), "Y should be unchanged");
    }
}

--- END: ./src/SpaceStation.Tests/MovementTests.cs ---

--- START: ./src/SpaceStation.Tests/AtmosTests.cs ---
using System.Numerics;
using Arch.Core;
using SpaceStation.Content.Components;
using SpaceStation.Content.Systems;

namespace SpaceStation.Tests;

/// <summary>
/// Tests for atmosphere system pressure equalization.
/// </summary>
[TestFixture]
public class AtmosTests
{
    private World _world = null!;
    private AtmosSystem _atmosSystem = null!;

    [SetUp]
    public void Setup()
    {
        _world = World.Create();
        _atmosSystem = new AtmosSystem();
    }

    [TearDown]
    public void Teardown()
    {
        _world.Dispose();
    }

    /// <summary>
    /// Test that Atmosphere.CreateStandard creates correct values.
    /// </summary>
    [Test]
    public void Test_CreateStandard_Atmosphere()
    {
        var atmos = Atmosphere.CreateStandard();

        Assert.That(atmos.Oxygen, Is.EqualTo(21f), "Standard O2 should be 21 moles");
        Assert.That(atmos.Nitrogen, Is.EqualTo(79f), "Standard N2 should be 79 moles");
        Assert.That(atmos.CarbonDioxide, Is.EqualTo(0f), "Standard CO2 should be 0 moles");
        Assert.That(atmos.Plasma, Is.EqualTo(0f), "Standard Plasma should be 0 moles");
        Assert.That(atmos.Temperature, Is.EqualTo(293.15f).Within(0.1f), "Standard temp should be ~20C");
        Assert.That(atmos.TotalMoles, Is.EqualTo(100f), "Total should be 100 moles");
    }

    /// <summary>
    /// Test that IsBreathable correctly identifies breathable atmosphere.
    /// </summary>
    [Test]
    public void Test_IsBreathable()
    {
        var standard = Atmosphere.CreateStandard();
        var vacuum = new Atmosphere { Oxygen = 0, Nitrogen = 0, Volume = 2500f, Temperature = 293.15f };

        Assert.That(AtmosSystem.IsBreathable(in standard), Is.True, "Standard atmos should be breathable");
        Assert.That(AtmosSystem.IsBreathable(in vacuum), Is.False, "Vacuum should not be breathable");
    }

    /// <summary>
    /// Test that isolated tiles don't lose gas.
    /// </summary>
    [Test]
    public void Test_Isolated_Tile_Stability()
    {
        // Arrange: Single tile with atmosphere
        var tile = _world.Create(
            new Transform(new Vector2(0, 0), 0f, 0),
            Atmosphere.CreateStandard()
        );

        var atmos_before = _world.Get<Atmosphere>(tile);
        float moles_before = atmos_before.TotalMoles;

        // Act: Simulate
        for (int i = 0; i < 100; i++)
        {
            _atmosSystem.Update(0.05f, _world);
        }

        // Assert: Gas should remain stable
        var atmos_after = _world.Get<Atmosphere>(tile);
        Assert.That(atmos_after.TotalMoles, Is.EqualTo(moles_before).Within(0.1f),
            "Isolated tile should maintain gas levels");
    }

    /// <summary>
    /// Test pressure equalization between adjacent tiles.
    /// NOTE: Requires gas flow implementation in AtmosSystem.
    /// </summary>
    [Test]
    [Ignore("Gas flow not yet implemented in AtmosSystem")]
    public void Test_Vacuum_Equalization()
    {
        // TODO: Implement after AtmosSystem gas flow is added
        Assert.Pass("Placeholder for gas equalization test");
    }
}

--- END: ./src/SpaceStation.Tests/AtmosTests.cs ---
